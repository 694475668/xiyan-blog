{"version":3,"file":"FileWriter.js","sourceRoot":"","sources":["../src/FileWriter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,qCAAkC;AAElC,MAAM,GAAG,GAA8B,eAAM,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;AA8BxE;;;GAGG;AACH,MAAa,UAAU;IAQrB,YAAoB,cAAsB,EAAE,QAAgB;QAC1D,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,IAAI,CAAC,QAAgB,EAAE,KAAwB;QAC3D,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,UAAU,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;IAClG,CAAC;IAED;;;OAGG;IACK,MAAM,CAAC,oBAAoB,CAAC,KAAmC;QACrE,KAAK,mBACH,MAAM,EAAE,KAAK,EACb,SAAS,EAAE,KAAK,IACb,KAAK,CACT,CAAC;QACF,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAkB,CAAC;IAC1F,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,IAAY;QACvB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAC;SACrF;QAED,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;IAC5C,CAAC;IAED;;;;;;OAMG;IACI,KAAK;QACV,MAAM,EAAE,GAAuB,IAAI,CAAC,eAAe,CAAC;QACpD,IAAI,EAAE,EAAE;YACN,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;YACjC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;SACnB;IACH,CAAC;CACF;AAjED,gCAiEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { Import } from './Import';\r\n\r\nconst fsx: typeof import('fs-extra') = Import.lazy('fs-extra', require);\r\n\r\n/**\r\n * Available file handle opening flags.\r\n * @public\r\n */\r\ntype NodeFileFlags = 'r' | 'r+' | 'rs+' | 'w' | 'wx' | 'w+' | 'wx+' | 'a' | 'ax' | 'a+' | 'ax+';\r\n\r\n/**\r\n * Interface which represents the flags about which mode the file should be opened in.\r\n * @public\r\n */\r\nexport interface IFileWriterFlags {\r\n  /**\r\n   * Open file for appending.\r\n   */\r\n  append?: boolean;\r\n\r\n  /**\r\n   * Fails if path exists. The exclusive flag ensures that path is newly created.\r\n   *\r\n   * @remarks\r\n   * On POSIX-like operating systems, path is considered to exist even if it is a symlink to a\r\n   * non-existent file.  The exclusive flag may or may not work with network file systems.\r\n   *\r\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\r\n   */\r\n  exclusive?: boolean;\r\n}\r\n\r\n/**\r\n * API for interacting with file handles.\r\n * @public\r\n */\r\nexport class FileWriter {\r\n  /**\r\n   * The `filePath` that was passed to {@link FileWriter.open}.\r\n   */\r\n  public readonly filePath: string;\r\n\r\n  private _fileDescriptor: number | undefined;\r\n\r\n  private constructor(fileDescriptor: number, filePath: string) {\r\n    this._fileDescriptor = fileDescriptor;\r\n    this.filePath = filePath;\r\n  }\r\n\r\n  /**\r\n   * Opens a new file handle to the file at the specified path and given mode.\r\n   * Behind the scenes it uses `fs.openSync()`.\r\n   * The behaviour of this function is platform specific.\r\n   * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback\r\n   * @param filePath - The absolute or relative path to the file handle that should be opened.\r\n   * @param flags - The flags for opening the handle\r\n   */\r\n  public static open(filePath: string, flags?: IFileWriterFlags): FileWriter {\r\n    return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);\r\n  }\r\n\r\n  /**\r\n   * Helper function to convert the file writer array to a Node.js style string (e.g. \"wx\" or \"a\").\r\n   * @param flags - The flags that should be converted.\r\n   */\r\n  private static _convertFlagsForNode(flags: IFileWriterFlags | undefined): NodeFileFlags {\r\n    flags = {\r\n      append: false,\r\n      exclusive: false,\r\n      ...flags\r\n    };\r\n    return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('') as NodeFileFlags;\r\n  }\r\n\r\n  /**\r\n   * Writes some text to the given file handle. Throws if the file handle has been closed.\r\n   * Behind the scenes it uses `fs.writeSync()`.\r\n   * @param text - The text to write to the file.\r\n   */\r\n  public write(text: string): void {\r\n    if (!this._fileDescriptor) {\r\n      throw new Error(`Cannot write to file, file descriptor has already been released.`);\r\n    }\r\n\r\n    fsx.writeSync(this._fileDescriptor, text);\r\n  }\r\n\r\n  /**\r\n   * Closes the file handle permanently. No operations can be made on this file handle after calling this.\r\n   * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.\r\n   *\r\n   * @remarks\r\n   * The `close()` method can be called more than once; additional calls are ignored.\r\n   */\r\n  public close(): void {\r\n    const fd: number | undefined = this._fileDescriptor;\r\n    if (fd) {\r\n      this._fileDescriptor = undefined;\r\n      fsx.closeSync(fd);\r\n    }\r\n  }\r\n}\r\n"]}