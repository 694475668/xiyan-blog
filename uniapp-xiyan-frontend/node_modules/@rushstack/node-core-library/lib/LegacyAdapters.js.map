{"version":3,"file":"LegacyAdapters.js","sourceRoot":"","sources":["../src/LegacyAdapters.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,qCAA0C;AAC1C,+CAAiC;AASjC;;;GAGG;AACH,MAAa,cAAc;IA+BlB,MAAM,CAAC,wBAAwB,CACpC,EAMS,EACT,IAAY,EACZ,IAAY,EACZ,IAAY,EACZ,IAAY;QAEZ,OAAO,IAAI,OAAO,CAAC,CAAC,OAAkC,EAAE,MAA8B,EAAE,EAAE;YACxF,MAAM,EAAE,GAAoC,CAAC,KAAgC,EAAE,MAAe,EAAE,EAAE;gBAChG,IAAI,KAAK,EAAE;oBACT,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC1C;qBAAM;oBACL,OAAO,CAAC,MAAM,CAAC,CAAC;iBACjB;YACH,CAAC,CAAC;YAEF,IAAI;gBACF,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE;oBACxF,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;iBAChC;qBAAM,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE;oBACzE,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;iBAC1B;qBAAM,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE;oBACnD,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;iBACpB;qBAAM,IAAI,IAAI,KAAK,SAAS,EAAE;oBAC7B,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;iBACd;qBAAM;oBACL,EAAE,CAAC,EAAE,CAAC,CAAC;iBACR;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,CAAC,CAAC,CAAC,CAAC;aACX;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,8DAA8D;IACvD,MAAM,CAAC,UAAU,CAAC,KAA2B;QAClD,IAAI,KAAK,YAAY,KAAK,EAAE;YAC1B,OAAO,KAAK,CAAC;SACd;aAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YACpC,OAAO,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;SACzB;aAAM;YACL,MAAM,WAAW,GAAU,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;YAC1D,WAAmB,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC,yDAAyD;YACjG,OAAO,WAAW,CAAC;SACpB;IACH,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,UAAU,CAAI,KAAU,EAAE,OAAgC;QACtE,IAAI,cAAc,CAAC,WAAW,KAAK,SAAS,EAAE;YAC5C,cAAc,CAAC,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;SACvE;QACD,IAAI,cAAc,CAAC,WAAW,EAAE;YAC9B,cAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SACzB;aAAM;YACL,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SAC3C;IACH,CAAC;;AAxGH,wCAyGC;AAxGgB,0BAAW,GAAwB,SAAS,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { sort as timsort } from 'timsort';\r\nimport * as semver from 'semver';\r\n\r\n/**\r\n * Callback used by {@link LegacyAdapters}.\r\n * @public\r\n */\r\n// eslint-disable-next-line @rushstack/no-new-null\r\nexport type LegacyCallback<TResult, TError> = (error: TError | null | undefined, result: TResult) => void;\r\n\r\n/**\r\n * Helper functions used when interacting with APIs that do not follow modern coding practices.\r\n * @public\r\n */\r\nexport class LegacyAdapters {\r\n  private static _useTimsort: boolean | undefined = undefined;\r\n\r\n  /**\r\n   * This function wraps a function with a callback in a promise.\r\n   */\r\n  public static convertCallbackToPromise<TResult, TError>(\r\n    fn: (cb: LegacyCallback<TResult, TError>) => void\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1>(\r\n    fn: (arg1: TArg1, cb: LegacyCallback<TResult, TError>) => void,\r\n    arg1: TArg1\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2>(\r\n    fn: (arg1: TArg1, arg2: TArg2, cb: LegacyCallback<TResult, TError>) => void,\r\n    arg1: TArg1,\r\n    arg2: TArg2\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3>(\r\n    fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, cb: LegacyCallback<TResult, TError>) => void,\r\n    arg1: TArg1,\r\n    arg2: TArg2,\r\n    arg3: TArg3\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3, TArg4>(\r\n    fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, arg4: TArg4, cb: LegacyCallback<TResult, TError>) => void,\r\n    arg1: TArg1,\r\n    arg2: TArg2,\r\n    arg3: TArg3,\r\n    arg4: TArg4\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3, TArg4>(\r\n    fn: (\r\n      a: TArg1 | LegacyCallback<TResult, TError>,\r\n      b?: TArg2 | LegacyCallback<TResult, TError>,\r\n      c?: TArg3 | LegacyCallback<TResult, TError>,\r\n      d?: TArg4 | LegacyCallback<TResult, TError>,\r\n      e?: TArg4 | LegacyCallback<TResult, TError>\r\n    ) => void,\r\n    arg1?: TArg1,\r\n    arg2?: TArg2,\r\n    arg3?: TArg3,\r\n    arg4?: TArg4\r\n  ): Promise<TResult> {\r\n    return new Promise((resolve: (result: TResult) => void, reject: (error: Error) => void) => {\r\n      const cb: LegacyCallback<TResult, TError> = (error: TError | null | undefined, result: TResult) => {\r\n        if (error) {\r\n          reject(LegacyAdapters.scrubError(error));\r\n        } else {\r\n          resolve(result);\r\n        }\r\n      };\r\n\r\n      try {\r\n        if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\r\n          fn(arg1, arg2, arg3, arg4, cb);\r\n        } else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {\r\n          fn(arg1, arg2, arg3, cb);\r\n        } else if (arg1 !== undefined && arg2 !== undefined) {\r\n          fn(arg1, arg2, cb);\r\n        } else if (arg1 !== undefined) {\r\n          fn(arg1, cb);\r\n        } else {\r\n          fn(cb);\r\n        }\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Normalizes an object into an `Error` object.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  public static scrubError(error: Error | string | any): Error {\r\n    if (error instanceof Error) {\r\n      return error;\r\n    } else if (typeof error === 'string') {\r\n      return new Error(error);\r\n    } else {\r\n      const errorObject: Error = new Error('An error occurred.');\r\n      (errorObject as any).errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      return errorObject;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.\r\n   * If you need a stable sort, you can use `sortStable()` as a workaround.\r\n   *\r\n   * @remarks\r\n   * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.\r\n   * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.\r\n   */\r\n  public static sortStable<T>(array: T[], compare?: (a: T, b: T) => number): void {\r\n    if (LegacyAdapters._useTimsort === undefined) {\r\n      LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;\r\n    }\r\n    if (LegacyAdapters._useTimsort) {\r\n      timsort(array, compare);\r\n    } else {\r\n      Array.prototype.sort.call(array, compare);\r\n    }\r\n  }\r\n}\r\n"]}