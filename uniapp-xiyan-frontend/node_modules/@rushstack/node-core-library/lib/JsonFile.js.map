{"version":3,"file":"JsonFile.js","sourceRoot":"","sources":["../src/JsonFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as os from 'os';\r\nimport * as jju from 'jju';\r\n\r\nimport { JsonSchema, IJsonSchemaErrorInfo, IJsonSchemaValidateOptions } from './JsonSchema';\r\nimport { Text, NewlineKind } from './Text';\r\nimport { FileSystem } from './FileSystem';\r\n\r\n/**\r\n * Represents a JSON-serializable object whose type has not been determined yet.\r\n *\r\n * @remarks\r\n *\r\n * This type is similar to `any`, except that it communicates that the object is serializable JSON.\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type JsonObject = any;\r\n\r\n/**\r\n * The Rush Stack lint rules discourage usage of `null`.  However, JSON parsers always return JavaScript's\r\n * `null` to keep the two syntaxes consistent.  When creating interfaces that describe JSON structures,\r\n * use `JsonNull` to avoid triggering the lint rule.  Do not use `JsonNull` for any other purpose.\r\n *\r\n * @remarks\r\n * If you are designing a new JSON file format, it's a good idea to avoid `null` entirely.  In most cases\r\n * there are better representations that convey more information about an item that is unknown, omitted, or disabled.\r\n *\r\n * To understand why `null` is deprecated, please see the `@rushstack/eslint-plugin` documentation here:\r\n *\r\n * {@link https://www.npmjs.com/package/@rushstack/eslint-plugin#rushstackno-null}\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @rushstack/no-new-null\r\nexport type JsonNull = null;\r\n\r\n/**\r\n * Options for JsonFile.stringify()\r\n *\r\n * @public\r\n */\r\nexport interface IJsonFileStringifyOptions {\r\n  /**\r\n   * If provided, the specified newline type will be used instead of the default `\\r\\n`.\r\n   */\r\n  newlineConversion?: NewlineKind;\r\n\r\n  /**\r\n   * If true, then the \"jju\" library will be used to improve the text formatting.\r\n   * Note that this is slightly slower than the native JSON.stringify() implementation.\r\n   */\r\n  prettyFormatting?: boolean;\r\n\r\n  /**\r\n   * If specified, this header will be prepended to the start of the file.  The header must consist\r\n   * of lines prefixed by \"//\" characters.\r\n   * @remarks\r\n   * When used with {@link IJsonFileSaveOptions.updateExistingFile}\r\n   * or {@link JsonFile.updateString}, the header will ONLY be added for a newly created file.\r\n   */\r\n  headerComment?: string;\r\n}\r\n\r\n/**\r\n * Options for JsonFile.saveJsonFile()\r\n *\r\n * @public\r\n */\r\nexport interface IJsonFileSaveOptions extends IJsonFileStringifyOptions {\r\n  /**\r\n   * If there is an existing file, and the contents have not changed, then\r\n   * don't write anything; this preserves the old timestamp.\r\n   */\r\n  onlyIfChanged?: boolean;\r\n\r\n  /**\r\n   * Creates the folder recursively using FileSystem.ensureFolder()\r\n   * Defaults to false.\r\n   */\r\n  ensureFolderExists?: boolean;\r\n\r\n  /**\r\n   * If true, use the \"jju\" library to preserve the existing JSON formatting:  The file will be loaded\r\n   * from the target filename, the new content will be merged in (preserving whitespace and comments),\r\n   * and then the file will be overwritten with the merged contents.  If the target file does not exist,\r\n   * then the file is saved normally.\r\n   */\r\n  updateExistingFile?: boolean;\r\n}\r\n\r\nconst DEFAULT_ENCODING: string = 'utf8';\r\n\r\n/**\r\n * Utilities for reading/writing JSON files.\r\n * @public\r\n */\r\nexport class JsonFile {\r\n  /**\r\n   * @internal\r\n   */\r\n  public static _formatPathForError: (path: string) => string = (path: string) => path;\r\n\r\n  /**\r\n   * Loads a JSON file.\r\n   */\r\n  public static load(jsonFilename: string): JsonObject {\r\n    try {\r\n      const contents: string = FileSystem.readFile(jsonFilename);\r\n      return jju.parse(contents);\r\n    } catch (error) {\r\n      if (FileSystem.isNotExistError(error)) {\r\n        throw error;\r\n      } else {\r\n        throw new Error(\r\n          `Error reading \"${JsonFile._formatPathForError(jsonFilename)}\":` + os.EOL + `  ${error.message}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link JsonFile.load}.\r\n   */\r\n  public static async loadAsync(jsonFilename: string): Promise<JsonObject> {\r\n    try {\r\n      const contents: string = await FileSystem.readFileAsync(jsonFilename);\r\n      return jju.parse(contents);\r\n    } catch (error) {\r\n      if (FileSystem.isNotExistError(error)) {\r\n        throw error;\r\n      } else {\r\n        throw new Error(\r\n          `Error reading \"${JsonFile._formatPathForError(jsonFilename)}\":` + os.EOL + `  ${error.message}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses a JSON file's contents.\r\n   */\r\n  public static parseString(jsonContents: string): JsonObject {\r\n    return jju.parse(jsonContents);\r\n  }\r\n\r\n  /**\r\n   * Loads a JSON file and validate its schema.\r\n   */\r\n  public static loadAndValidate(\r\n    jsonFilename: string,\r\n    jsonSchema: JsonSchema,\r\n    options?: IJsonSchemaValidateOptions\r\n  ): JsonObject {\r\n    const jsonObject: JsonObject = JsonFile.load(jsonFilename);\r\n    jsonSchema.validateObject(jsonObject, jsonFilename, options);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link JsonFile.loadAndValidate}.\r\n   */\r\n  public static async loadAndValidateAsync(\r\n    jsonFilename: string,\r\n    jsonSchema: JsonSchema,\r\n    options?: IJsonSchemaValidateOptions\r\n  ): Promise<JsonObject> {\r\n    const jsonObject: JsonObject = await JsonFile.loadAsync(jsonFilename);\r\n    jsonSchema.validateObject(jsonObject, jsonFilename, options);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * Loads a JSON file and validate its schema, reporting errors using a callback\r\n   * @remarks\r\n   * See JsonSchema.validateObjectWithCallback() for more info.\r\n   */\r\n  public static loadAndValidateWithCallback(\r\n    jsonFilename: string,\r\n    jsonSchema: JsonSchema,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void\r\n  ): JsonObject {\r\n    const jsonObject: JsonObject = JsonFile.load(jsonFilename);\r\n    jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link JsonFile.loadAndValidateWithCallback}.\r\n   */\r\n  public static async loadAndValidateWithCallbackAsync(\r\n    jsonFilename: string,\r\n    jsonSchema: JsonSchema,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void\r\n  ): Promise<JsonObject> {\r\n    const jsonObject: JsonObject = await JsonFile.loadAsync(jsonFilename);\r\n    jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * Serializes the specified JSON object to a string buffer.\r\n   * @param jsonObject - the object to be serialized\r\n   * @param options - other settings that control serialization\r\n   * @returns a JSON string, with newlines, and indented with two spaces\r\n   */\r\n  public static stringify(jsonObject: JsonObject, options?: IJsonFileStringifyOptions): string {\r\n    return JsonFile.updateString('', jsonObject, options);\r\n  }\r\n\r\n  /**\r\n   * Serializes the specified JSON object to a string buffer.\r\n   * @param jsonObject - the object to be serialized\r\n   * @param options - other settings that control serialization\r\n   * @returns a JSON string, with newlines, and indented with two spaces\r\n   */\r\n  public static updateString(\r\n    previousJson: string,\r\n    newJsonObject: JsonObject,\r\n    options?: IJsonFileStringifyOptions\r\n  ): string {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    JsonFile.validateNoUndefinedMembers(newJsonObject);\r\n\r\n    let stringified: string;\r\n\r\n    if (previousJson !== '') {\r\n      // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON\r\n      stringified = jju.update(previousJson, newJsonObject, {\r\n        mode: 'cjson',\r\n        indent: 2\r\n      });\r\n    } else if (options.prettyFormatting) {\r\n      stringified = jju.stringify(newJsonObject, {\r\n        mode: 'json',\r\n        indent: 2\r\n      });\r\n\r\n      if (options.headerComment !== undefined) {\r\n        stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;\r\n      }\r\n    } else {\r\n      stringified = JSON.stringify(newJsonObject, undefined, 2);\r\n\r\n      if (options.headerComment !== undefined) {\r\n        stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;\r\n      }\r\n    }\r\n\r\n    // Add the trailing newline\r\n    stringified = Text.ensureTrailingNewline(stringified);\r\n\r\n    if (options && options.newlineConversion) {\r\n      stringified = Text.convertTo(stringified, options.newlineConversion);\r\n    }\r\n\r\n    return stringified;\r\n  }\r\n\r\n  /**\r\n   * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.\r\n   * @param jsonObject - the object to be saved\r\n   * @param jsonFilename - the file path to write\r\n   * @param options - other settings that control how the file is saved\r\n   * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise\r\n   */\r\n  public static save(jsonObject: JsonObject, jsonFilename: string, options?: IJsonFileSaveOptions): boolean {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    // Do we need to read the previous file contents?\r\n    let oldBuffer: Buffer | undefined = undefined;\r\n    if (options.updateExistingFile || options.onlyIfChanged) {\r\n      try {\r\n        oldBuffer = FileSystem.readFileToBuffer(jsonFilename);\r\n      } catch (error) {\r\n        if (!FileSystem.isNotExistError(error)) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    let jsonToUpdate: string = '';\r\n    if (options.updateExistingFile && oldBuffer) {\r\n      jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);\r\n    }\r\n\r\n    const newJson: string = JsonFile.updateString(jsonToUpdate, jsonObject, options);\r\n\r\n    const newBuffer: Buffer = Buffer.from(newJson, DEFAULT_ENCODING);\r\n\r\n    if (options.onlyIfChanged) {\r\n      // Has the file changed?\r\n      if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\r\n        // Nothing has changed, so don't touch the file\r\n        return false;\r\n      }\r\n    }\r\n\r\n    FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {\r\n      ensureFolderExists: options.ensureFolderExists\r\n    });\r\n\r\n    // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.\r\n    /*\r\n    const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);\r\n    if (Buffer.compare(buffer, oldBuffer2) !== 0) {\r\n      console.log('new:' + buffer.toString('hex'));\r\n      console.log('old:' + oldBuffer2.toString('hex'));\r\n\r\n      throw new Error('onlyIfChanged logic is broken');\r\n    }\r\n    */\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link JsonFile.loadAndValidateWithCallback}.\r\n   */\r\n  public static async saveAsync(\r\n    jsonObject: JsonObject,\r\n    jsonFilename: string,\r\n    options?: IJsonFileSaveOptions\r\n  ): Promise<boolean> {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    // Do we need to read the previous file contents?\r\n    let oldBuffer: Buffer | undefined = undefined;\r\n    if (options.updateExistingFile || options.onlyIfChanged) {\r\n      try {\r\n        oldBuffer = await FileSystem.readFileToBufferAsync(jsonFilename);\r\n      } catch (error) {\r\n        if (!FileSystem.isNotExistError(error)) {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    let jsonToUpdate: string = '';\r\n    if (options.updateExistingFile && oldBuffer) {\r\n      jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);\r\n    }\r\n\r\n    const newJson: string = JsonFile.updateString(jsonToUpdate, jsonObject, options);\r\n\r\n    const newBuffer: Buffer = Buffer.from(newJson, DEFAULT_ENCODING);\r\n\r\n    if (options.onlyIfChanged) {\r\n      // Has the file changed?\r\n      if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\r\n        // Nothing has changed, so don't touch the file\r\n        return false;\r\n      }\r\n    }\r\n\r\n    await FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {\r\n      ensureFolderExists: options.ensureFolderExists\r\n    });\r\n\r\n    // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.\r\n    /*\r\n    const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);\r\n    if (Buffer.compare(buffer, oldBuffer2) !== 0) {\r\n      console.log('new:' + buffer.toString('hex'));\r\n      console.log('old:' + oldBuffer2.toString('hex'));\r\n\r\n      throw new Error('onlyIfChanged logic is broken');\r\n    }\r\n    */\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Used to validate a data structure before writing.  Reports an error if there\r\n   * are any undefined members.\r\n   */\r\n  public static validateNoUndefinedMembers(jsonObject: JsonObject): void {\r\n    return JsonFile._validateNoUndefinedMembers(jsonObject, []);\r\n  }\r\n\r\n  // Private implementation of validateNoUndefinedMembers()\r\n  private static _validateNoUndefinedMembers(jsonObject: JsonObject, keyPath: string[]): void {\r\n    if (!jsonObject) {\r\n      return;\r\n    }\r\n    if (typeof jsonObject === 'object') {\r\n      for (const key of Object.keys(jsonObject)) {\r\n        keyPath.push(key);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const value: any = jsonObject[key];\r\n        if (value === undefined) {\r\n          const fullPath: string = JsonFile._formatKeyPath(keyPath);\r\n          throw new Error(`The value for ${fullPath} is \"undefined\" and cannot be serialized as JSON`);\r\n        }\r\n\r\n        JsonFile._validateNoUndefinedMembers(value, keyPath);\r\n        keyPath.pop();\r\n      }\r\n    }\r\n  }\r\n\r\n  // Given this input:    ['items', '4', 'syntax', 'parameters', 'string \"with\" symbols\", 'type']\r\n  // Return this string:  items[4].syntax.parameters[\"string \\\"with\\\" symbols\"].type\r\n  private static _formatKeyPath(keyPath: string[]): string {\r\n    let result: string = '';\r\n\r\n    for (const key of keyPath) {\r\n      if (/^[0-9]+$/.test(key)) {\r\n        // It's an integer, so display like this:  parent[123]\r\n        result += `[${key}]`;\r\n      } else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {\r\n        // It's an alphanumeric identifier, so display like this:  parent.name\r\n        if (result) {\r\n          result += '.';\r\n        }\r\n        result += `${key}`;\r\n      } else {\r\n        // It's a freeform string, so display like this:  parent[\"A path: \\\"C:\\\\file\\\"\"]\r\n\r\n        // Convert this:     A path: \"C:\\file\"\r\n        // To this:          A path: \\\"C:\\\\file\\\"\r\n        const escapedKey: string = key\r\n          .replace(/[\\\\]/g, '\\\\\\\\') // escape backslashes\r\n          .replace(/[\"]/g, '\\\\'); // escape quotes\r\n        result += `[\"${escapedKey}\"]`;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static _formatJsonHeaderComment(headerComment: string): string {\r\n    if (headerComment === '') {\r\n      return '';\r\n    }\r\n    const lines: string[] = headerComment.split('\\n');\r\n    const result: string[] = [];\r\n    for (const line of lines) {\r\n      if (!/^\\s*$/.test(line) && !/^\\s*\\/\\//.test(line)) {\r\n        throw new Error(\r\n          'The headerComment lines must be blank or start with the \"//\" prefix.\\n' +\r\n            'Invalid line' +\r\n            JSON.stringify(line)\r\n        );\r\n      }\r\n      result.push(Text.replaceAll(line, '\\r', ''));\r\n    }\r\n    return lines.join('\\n') + '\\n';\r\n  }\r\n}\r\n"]}