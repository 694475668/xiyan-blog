{"version":3,"file":"Path.js","sourceRoot":"","sources":["../src/Path.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,iCAA8B;AAiB9B;;;;;GAKG;AACH,MAAa,IAAI;IASf;;;;;;;;;OASG;IACI,MAAM,CAAC,OAAO,CAAC,SAAiB,EAAE,gBAAwB;QAC/D,6EAA6E;QAC7E,uEAAuE;QACvE,sFAAsF;QACtF,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QACxE,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACpD,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,cAAc,CAAC,SAAiB,EAAE,gBAAwB;QACtE,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QACxE,OAAO,YAAY,KAAK,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC3E,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,KAAa;QAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC;IAC5C,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,eAAe,CAAC,OAAoC;QAChE,sCAAsC;QACtC,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;QACtF,MAAM,cAAc,GAAY,YAAY,KAAK,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAElG,IAAI,cAAc,EAAE;YAClB,qEAAqE;YACrE,OAAO,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;SAC/F;QAED,MAAM,YAAY,GAAW,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;QACjE,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,gBAAgB,CAAC,SAAiB;QAC9C,OAAO,WAAI,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,oBAAoB,CAAC,SAAiB;QAClD,OAAO,WAAI,CAAC,UAAU,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;;;;;;;;;;;;;OAiBG;IACI,MAAM,CAAC,kBAAkB,CAAC,SAAiB;QAChD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;YAC9B,OAAO,KAAK,CAAC;SACd;QACD,uBAAuB;QACvB,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAChD,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC;;AAzHH,oBA0HC;AAzHC,qEAAqE;AACrE,mCAAmC;AACpB,uBAAkB,GAAW,YAAY,CAAC;AAEzD,yDAAyD;AACzD,oBAAoB;AACL,4BAAuB,GAAW,0BAA0B,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { Text } from './Text';\r\n\r\n/**\r\n * Options for {@link Path.formatConcisely}.\r\n * @public\r\n */\r\nexport interface IPathFormatConciselyOptions {\r\n  /**\r\n   * The path to be converted.\r\n   */\r\n  pathToConvert: string;\r\n  /**\r\n   * The base path to use when converting `pathToConvert` to a relative path.\r\n   */\r\n  baseFolder: string;\r\n}\r\n\r\n/**\r\n * Common operations for manipulating file and directory paths.\r\n * @remarks\r\n * This API is intended to eventually be a complete replacement for the NodeJS \"path\" API.\r\n * @public\r\n */\r\nexport class Path {\r\n  // Matches a relative path consisting entirely of periods and slashes\r\n  // Example: \".\", \"..\", \"../..\", etc\r\n  private static _relativePathRegex: RegExp = /^[.\\/\\\\]+$/;\r\n\r\n  // Matches a relative path segment that traverses upwards\r\n  // Example: \"a/../b\"\r\n  private static _upwardPathSegmentRegex: RegExp = /([\\/\\\\]|^)\\.\\.([\\/\\\\]|$)/;\r\n\r\n  /**\r\n   * Returns true if \"childPath\" is located inside the \"parentFolderPath\" folder\r\n   * or one of its child folders.  Note that \"parentFolderPath\" is not considered to be\r\n   * under itself.  The \"childPath\" can refer to any type of file system object.\r\n   *\r\n   * @remarks\r\n   * The indicated file/folder objects are not required to actually exist on disk.\r\n   * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\r\n   * If the paths are relative, they will first be resolved using path.resolve().\r\n   */\r\n  public static isUnder(childPath: string, parentFolderPath: string): boolean {\r\n    // If childPath is under parentPath, then relativePath will be something like\r\n    // \"../..\" or \"..\\\\..\", which consists entirely of periods and slashes.\r\n    // (Note that something like \"....t\" is actually a valid filename, but \"....\" is not.)\r\n    const relativePath: string = path.relative(childPath, parentFolderPath);\r\n    return Path._relativePathRegex.test(relativePath);\r\n  }\r\n\r\n  /**\r\n   * Returns true if \"childPath\" is equal to \"parentFolderPath\", or if it is inside that folder\r\n   * or one of its children.  The \"childPath\" can refer to any type of file system object.\r\n   *\r\n   * @remarks\r\n   * The indicated file/folder objects are not required to actually exist on disk.\r\n   * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\r\n   * If the paths are relative, they will first be resolved using path.resolve().\r\n   */\r\n  public static isUnderOrEqual(childPath: string, parentFolderPath: string): boolean {\r\n    const relativePath: string = path.relative(childPath, parentFolderPath);\r\n    return relativePath === '' || Path._relativePathRegex.test(relativePath);\r\n  }\r\n\r\n  /**\r\n   * Returns true if `path1` and `path2` refer to the same underlying path.\r\n   *\r\n   * @remarks\r\n   *\r\n   * The comparison is performed using `path.relative()`.\r\n   */\r\n  public static isEqual(path1: string, path2: string): boolean {\r\n    return path.relative(path1, path2) === '';\r\n  }\r\n\r\n  /**\r\n   * Formats a path to look nice for reporting purposes.\r\n   * @remarks\r\n   * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.\r\n   * Otherwise, it will be converted to an absolute path.\r\n   *\r\n   * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\\`.\r\n   */\r\n  public static formatConcisely(options: IPathFormatConciselyOptions): string {\r\n    // Same logic as Path.isUnderOrEqual()\r\n    const relativePath: string = path.relative(options.pathToConvert, options.baseFolder);\r\n    const isUnderOrEqual: boolean = relativePath === '' || Path._relativePathRegex.test(relativePath);\r\n\r\n    if (isUnderOrEqual) {\r\n      // Note that isUnderOrEqual()'s relativePath is the reverse direction\r\n      return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));\r\n    }\r\n\r\n    const absolutePath: string = path.resolve(options.pathToConvert);\r\n    return absolutePath;\r\n  }\r\n\r\n  /**\r\n   * Replaces Windows-style backslashes with POSIX-style slashes.\r\n   *\r\n   * @remarks\r\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\r\n   */\r\n  public static convertToSlashes(inputPath: string): string {\r\n    return Text.replaceAll(inputPath, '\\\\', '/');\r\n  }\r\n\r\n  /**\r\n   * Replaces POSIX-style slashes with Windows-style backslashes\r\n   *\r\n   * @remarks\r\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\r\n   */\r\n  public static convertToBackslashes(inputPath: string): string {\r\n    return Text.replaceAll(inputPath, '/', '\\\\');\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified path is a relative path and does not use `..` to walk upwards.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * // These evaluate to true\r\n   * isDownwardRelative('folder');\r\n   * isDownwardRelative('file');\r\n   * isDownwardRelative('folder/');\r\n   * isDownwardRelative('./folder/');\r\n   * isDownwardRelative('./folder/file');\r\n   *\r\n   * // These evaluate to false\r\n   * isDownwardRelative('../folder');\r\n   * isDownwardRelative('folder/../file');\r\n   * isDownwardRelative('/folder/file');\r\n   * ```\r\n   */\r\n  public static isDownwardRelative(inputPath: string): boolean {\r\n    if (path.isAbsolute(inputPath)) {\r\n      return false;\r\n    }\r\n    // Does it contain \"..\"\r\n    if (Path._upwardPathSegmentRegex.test(inputPath)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n"]}