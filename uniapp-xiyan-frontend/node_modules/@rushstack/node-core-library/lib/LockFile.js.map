{"version":3,"file":"LockFile.js","sourceRoot":"","sources":["../src/LockFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as child_process from 'child_process';\r\nimport { setTimeout } from 'timers';\r\nimport { FileSystem } from './FileSystem';\r\nimport { FileWriter } from './FileWriter';\r\n\r\n/**\r\n * http://man7.org/linux/man-pages/man5/proc.5.html\r\n * (22) starttime  %llu\r\n * The time the process started after system boot. In kernels before Linux 2.6, this value was\r\n * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by\r\n * sysconf(_SC_CLK_TCK)).\r\n * The format for this field was %lu before Linux 2.6.\r\n */\r\nconst procStatStartTimePos: number = 22;\r\n\r\n/**\r\n * Parses the process start time from the contents of a linux /proc/[pid]/stat file.\r\n * @param stat - The contents of a linux /proc/[pid]/stat file.\r\n * @returns The process start time in jiffies, or undefined if stat has an unexpected format.\r\n */\r\nexport function getProcessStartTimeFromProcStat(stat: string): string | undefined {\r\n  // Parse the value at position procStatStartTimePos.\r\n  // We cannot just split stat on spaces, because value 2 may contain spaces.\r\n  // For example, when running the following Shell commands:\r\n  // > cp \"$(which bash)\" ./'bash 2)('\r\n  // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'\r\n  // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0\r\n  // > rm -rf ./'bash 2)('\r\n  // The output shows a stat file such that value 2 contains spaces.\r\n  // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...\r\n\r\n  // trimRight to remove the trailing line terminator.\r\n  let values: string[] = stat.trimRight().split(' ');\r\n  let i: number = values.length - 1;\r\n  while (\r\n    i >= 0 &&\r\n    // charAt returns an empty string if the index is out of bounds.\r\n    values[i].charAt(values[i].length - 1) !== ')'\r\n  ) {\r\n    i -= 1;\r\n  }\r\n  // i is the index of the last part of the second value (but i need not be 1).\r\n  if (i < 1) {\r\n    // Format of stat has changed.\r\n    return undefined;\r\n  }\r\n  const value2: string = values.slice(1, i + 1).join(' ');\r\n  values = [values[0], value2].concat(values.slice(i + 1));\r\n  if (values.length < procStatStartTimePos) {\r\n    // Older version of linux, or non-standard configuration of linux.\r\n    return undefined;\r\n  }\r\n  const startTimeJiffies: string = values[procStatStartTimePos - 1];\r\n  // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change\r\n  // while the system is running, but we assume this does not happen.\r\n  // So the caller can safely use this value as part of a unique process id (on the machine, without comparing\r\n  // accross reboots).\r\n  return startTimeJiffies;\r\n}\r\n\r\n/**\r\n * Helper function that is exported for unit tests only.\r\n * Returns undefined if the process doesn't exist with that pid.\r\n */\r\nexport function getProcessStartTime(pid: number): string | undefined {\r\n  const pidString: string = pid.toString();\r\n  if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {\r\n    throw new Error(`\"pid\" is negative or too large`);\r\n  }\r\n  let args: string[];\r\n  if (process.platform === 'darwin') {\r\n    args = [`-p ${pidString}`, '-o lstart'];\r\n  } else if (process.platform === 'linux') {\r\n    args = ['-p', pidString, '-o', 'lstart'];\r\n  } else {\r\n    throw new Error(`Unsupported system: ${process.platform}`);\r\n  }\r\n\r\n  const psResult: child_process.SpawnSyncReturns<string> = child_process.spawnSync('ps', args, {\r\n    encoding: 'utf8'\r\n  });\r\n  const psStdout: string = psResult.stdout;\r\n\r\n  // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.\r\n  // But if no process exists we do not want to fall back on /proc/*/stat to determine the process\r\n  // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if\r\n  // zero bytes are written to stdout.\r\n  if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {\r\n    // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.\r\n    let stat: undefined | string;\r\n    try {\r\n      stat = FileSystem.readFile(`/proc/${pidString}/stat`);\r\n    } catch (error) {\r\n      if (error.code !== 'ENOENT') {\r\n        throw error;\r\n      }\r\n      // Either no process with PID pid exists, or this version/configuration of linux is non-standard.\r\n      // We assume the former.\r\n      return undefined;\r\n    }\r\n    if (stat !== undefined) {\r\n      const startTimeJiffies: string | undefined = getProcessStartTimeFromProcStat(stat);\r\n      if (startTimeJiffies === undefined) {\r\n        throw new Error(\r\n          `Could not retrieve the start time of process ${pidString} from the OS because the ` +\r\n            `contents of /proc/${pidString}/stat have an unexpected format`\r\n        );\r\n      }\r\n      return startTimeJiffies;\r\n    }\r\n  }\r\n\r\n  // there was an error executing ps (zero bytes were written to stdout).\r\n  if (!psStdout) {\r\n    throw new Error(`Unexpected output from \"ps\" command`);\r\n  }\r\n\r\n  const psSplit: string[] = psStdout.split('\\n');\r\n\r\n  // successfuly able to run \"ps\", but no process was found\r\n  if (psSplit[1] === '') {\r\n    return undefined;\r\n  }\r\n\r\n  if (psSplit[1]) {\r\n    const trimmed: string = psSplit[1].trim();\r\n    if (trimmed.length > 10) {\r\n      return trimmed;\r\n    }\r\n  }\r\n\r\n  throw new Error(`Unexpected output from the \"ps\" command`);\r\n}\r\n\r\n/**\r\n * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource\r\n * between multiple Node.js processes.  It is not recommended for synchronization solely within\r\n * a single Node.js process.\r\n * @remarks\r\n * The implementation works on Windows, Mac, and Linux without requiring any native helpers.\r\n * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,\r\n * it requires access the `/proc/${pidString}/stat` filesystem.\r\n * @public\r\n */\r\nexport class LockFile {\r\n  private static _getStartTime: (pid: number) => string | undefined = getProcessStartTime;\r\n\r\n  private _fileWriter: FileWriter | undefined;\r\n  private _filePath: string;\r\n  private _dirtyWhenAcquired: boolean;\r\n\r\n  private constructor(fileWriter: FileWriter | undefined, filePath: string, dirtyWhenAcquired: boolean) {\r\n    this._fileWriter = fileWriter;\r\n    this._filePath = filePath;\r\n    this._dirtyWhenAcquired = dirtyWhenAcquired;\r\n  }\r\n\r\n  /**\r\n   * Returns the path of the lockfile that will be created when a lock is successfully acquired.\r\n   * @param resourceFolder - The folder where the lock file will be created\r\n   * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become\r\n   *   the filename of the temporary file created to manage the lock.\r\n   * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.\r\n   */\r\n  public static getLockFilePath(\r\n    resourceFolder: string,\r\n    resourceName: string,\r\n    pid: number = process.pid\r\n  ): string {\r\n    if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {\r\n      throw new Error(\r\n        `The resource name \"${resourceName}\" is invalid.` +\r\n          ` It must be an alphanumberic string with only \"-\" or \".\" It must start with an alphanumeric character.`\r\n      );\r\n    }\r\n\r\n    if (process.platform === 'win32') {\r\n      return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);\r\n    } else if (process.platform === 'linux' || process.platform === 'darwin') {\r\n      return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);\r\n    }\r\n\r\n    throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\r\n  }\r\n\r\n  /**\r\n   * Attempts to create a lockfile with the given filePath.\r\n   * @param resourceFolder - The folder where the lock file will be created\r\n   * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become\r\n   *   the filename of the temporary file created to manage the lock.\r\n   * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.\r\n   */\r\n  public static tryAcquire(resourceFolder: string, resourceName: string): LockFile | undefined {\r\n    FileSystem.ensureFolder(resourceFolder);\r\n    if (process.platform === 'win32') {\r\n      return LockFile._tryAcquireWindows(resourceFolder, resourceName);\r\n    } else if (process.platform === 'linux' || process.platform === 'darwin') {\r\n      return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);\r\n    }\r\n    throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\r\n  }\r\n\r\n  /**\r\n   * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available\r\n   * or the maxWaitMs is surpassed.\r\n   *\r\n   * @remarks\r\n   * This function is subject to starvation, whereby it does not ensure that the process that has been\r\n   * waiting the longest to acquire the lock will get it first. This means that a process could theoretically\r\n   * wait for the lock forever, while other processes skipped it in line and acquired the lock first.\r\n   *\r\n   * @param resourceFolder - The folder where the lock file will be created\r\n   * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become\r\n   *   the filename of the temporary file created to manage the lock.\r\n   * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error\r\n   */\r\n  public static acquire(resourceFolder: string, resourceName: string, maxWaitMs?: number): Promise<LockFile> {\r\n    const interval: number = 100;\r\n    const startTime: number = Date.now();\r\n\r\n    const retryLoop: () => Promise<LockFile> = async () => {\r\n      const lock: LockFile | undefined = LockFile.tryAcquire(resourceFolder, resourceName);\r\n      if (lock) {\r\n        return lock;\r\n      }\r\n      if (maxWaitMs && Date.now() > startTime + maxWaitMs) {\r\n        throw new Error(`Exceeded maximum wait time to acquire lock for resource \"${resourceName}\"`);\r\n      }\r\n\r\n      await LockFile._sleepForMs(interval);\r\n      return retryLoop();\r\n    };\r\n\r\n    return retryLoop();\r\n  }\r\n\r\n  private static _sleepForMs(timeout: number): Promise<void> {\r\n    return new Promise<void>((resolve: () => void, reject: () => void) => {\r\n      setTimeout(() => {\r\n        resolve();\r\n      }, timeout);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempts to acquire the lock on a Linux or OSX machine\r\n   */\r\n  private static _tryAcquireMacOrLinux(resourceFolder: string, resourceName: string): LockFile | undefined {\r\n    let dirtyWhenAcquired: boolean = false;\r\n\r\n    // get the current process' pid\r\n    const pid: number = process.pid;\r\n    const startTime: string | undefined = LockFile._getStartTime(pid);\r\n\r\n    if (!startTime) {\r\n      throw new Error(`Unable to calculate start time for current process.`);\r\n    }\r\n\r\n    const pidLockFilePath: string = LockFile.getLockFilePath(resourceFolder, resourceName);\r\n    let lockFileHandle: FileWriter | undefined;\r\n\r\n    let lockFile: LockFile;\r\n\r\n    try {\r\n      // open in write mode since if this file exists, it cannot be from the current process\r\n      // TODO: This will malfunction if the same process tries to acquire two locks on the same file.\r\n      // We should ideally maintain a dictionary of normalized acquired filenames\r\n      lockFileHandle = FileWriter.open(pidLockFilePath);\r\n      lockFileHandle.write(startTime);\r\n\r\n      const currentBirthTimeMs: number = FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();\r\n\r\n      let smallestBirthTimeMs: number = currentBirthTimeMs;\r\n      let smallestBirthTimePid: string = pid.toString();\r\n\r\n      // now, scan the directory for all lockfiles\r\n      const files: string[] = FileSystem.readFolder(resourceFolder);\r\n\r\n      // look for anything ending with # then numbers and \".lock\"\r\n      const lockFileRegExp: RegExp = /^(.+)#([0-9]+)\\.lock$/;\r\n\r\n      let match: RegExpMatchArray | null;\r\n      let otherPid: string;\r\n      for (const fileInFolder of files) {\r\n        if (\r\n          (match = fileInFolder.match(lockFileRegExp)) &&\r\n          match[1] === resourceName &&\r\n          (otherPid = match[2]) !== pid.toString()\r\n        ) {\r\n          // we found at least one lockfile hanging around that isn't ours\r\n          const fileInFolderPath: string = path.join(resourceFolder, fileInFolder);\r\n          dirtyWhenAcquired = true;\r\n\r\n          // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);\r\n\r\n          const otherPidCurrentStartTime: string | undefined = LockFile._getStartTime(parseInt(otherPid, 10));\r\n\r\n          let otherPidOldStartTime: string | undefined;\r\n          let otherBirthtimeMs: number | undefined;\r\n          try {\r\n            otherPidOldStartTime = FileSystem.readFile(fileInFolderPath);\r\n            // check the timestamp of the file\r\n            otherBirthtimeMs = FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();\r\n          } catch (err) {\r\n            // this means the file is probably deleted already\r\n          }\r\n\r\n          // if the otherPidOldStartTime is invalid, then we should look at the timestamp,\r\n          // if this file was created after us, ignore it\r\n          // if it was created within 1 second before us, then it could be good, so we\r\n          //  will conservatively fail\r\n          // otherwise it is an old lock file and will be deleted\r\n          if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {\r\n            if (otherBirthtimeMs > currentBirthTimeMs) {\r\n              // ignore this file, he will be unable to get the lock since this process\r\n              // will hold it\r\n              // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);\r\n              continue;\r\n            } else if (\r\n              otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND\r\n              otherBirthtimeMs - currentBirthTimeMs > -1000\r\n            ) {\r\n              // it was created less than a second before\r\n\r\n              // conservatively be unable to keep the lock\r\n              return undefined;\r\n            }\r\n          }\r\n\r\n          // console.log(`Other pid ${otherPid} lockfile has start time: \"${otherPidOldStartTime}\"`);\r\n          // console.log(`Other pid ${otherPid} actually has start time: \"${otherPidCurrentStartTime}\"`);\r\n\r\n          // this means the process is no longer executing, delete the file\r\n          if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {\r\n            // console.log(`Other pid ${otherPid} is no longer executing!`);\r\n            FileSystem.deleteFile(fileInFolderPath);\r\n            continue;\r\n          }\r\n\r\n          // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);\r\n          // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);\r\n          // this is a lockfile pointing at something valid\r\n          if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {\r\n            smallestBirthTimeMs = otherBirthtimeMs;\r\n            smallestBirthTimePid = otherPid;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (smallestBirthTimePid !== pid.toString()) {\r\n        // we do not have the lock\r\n        return undefined;\r\n      }\r\n\r\n      // we have the lock!\r\n      lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);\r\n      lockFileHandle = undefined; // we have handed the descriptor off to the instance\r\n    } finally {\r\n      if (lockFileHandle) {\r\n        // ensure our lock is closed\r\n        lockFileHandle.close();\r\n        FileSystem.deleteFile(pidLockFilePath);\r\n      }\r\n    }\r\n    return lockFile;\r\n  }\r\n\r\n  /**\r\n   * Attempts to acquire the lock using Windows\r\n   * This algorithm is much simpler since we can rely on the operating system\r\n   */\r\n  private static _tryAcquireWindows(resourceFolder: string, resourceName: string): LockFile | undefined {\r\n    const lockFilePath: string = LockFile.getLockFilePath(resourceFolder, resourceName);\r\n    let dirtyWhenAcquired: boolean = false;\r\n\r\n    let fileHandle: FileWriter | undefined;\r\n    let lockFile: LockFile;\r\n\r\n    try {\r\n      if (FileSystem.exists(lockFilePath)) {\r\n        dirtyWhenAcquired = true;\r\n\r\n        // If the lockfile is held by an process with an exclusive lock, then removing it will\r\n        // silently fail. OpenSync() below will then fail and we will be unable to create a lock.\r\n\r\n        // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that\r\n        // the last process to hold it died.\r\n        FileSystem.deleteFile(lockFilePath);\r\n      }\r\n\r\n      try {\r\n        // Attempt to open an exclusive lockfile\r\n        fileHandle = FileWriter.open(lockFilePath, { exclusive: true });\r\n      } catch (error) {\r\n        // we tried to delete the lock, but something else is holding it,\r\n        // (probably an active process), therefore we are unable to create a lock\r\n        return undefined;\r\n      }\r\n\r\n      // Ensure we can hand off the file descriptor to the lockfile\r\n      lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);\r\n      fileHandle = undefined;\r\n    } finally {\r\n      if (fileHandle) {\r\n        fileHandle.close();\r\n      }\r\n    }\r\n\r\n    return lockFile;\r\n  }\r\n\r\n  /**\r\n   * Unlocks a file and removes it from disk.\r\n   * This can only be called once.\r\n   */\r\n  public release(): void {\r\n    if (this.isReleased) {\r\n      throw new Error(`The lock for file \"${path.basename(this._filePath)}\" has already been released.`);\r\n    }\r\n\r\n    this._fileWriter!.close();\r\n    FileSystem.deleteFile(this._filePath);\r\n    this._fileWriter = undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the initial state of the lock.\r\n   * This can be used to detect if the previous process was terminated before releasing the resource.\r\n   */\r\n  public get dirtyWhenAcquired(): boolean {\r\n    return this._dirtyWhenAcquired;\r\n  }\r\n\r\n  /**\r\n   * Returns the absolute path to the lockfile\r\n   */\r\n  public get filePath(): string {\r\n    return this._filePath;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this lock is currently being held.\r\n   */\r\n  public get isReleased(): boolean {\r\n    return this._fileWriter === undefined;\r\n  }\r\n}\r\n"]}