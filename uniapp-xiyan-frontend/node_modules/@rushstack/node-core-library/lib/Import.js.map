{"version":3,"file":"Import.js","sourceRoot":"","sources":["../src/Import.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport importLazy = require('import-lazy');\r\nimport * as Resolve from 'resolve';\r\nimport nodeModule = require('module');\r\n\r\nimport { PackageJsonLookup } from './PackageJsonLookup';\r\nimport { FileSystem } from './FileSystem';\r\nimport { IPackageJson } from './IPackageJson';\r\n\r\n/**\r\n * Common options shared by {@link IImportResolveModuleOptions} and {@link IImportResolvePackageOptions}\r\n * @public\r\n */\r\nexport interface IImportResolveOptions {\r\n  /**\r\n   * The path from which {@link IImportResolveModuleOptions.modulePath} or\r\n   * {@link IImportResolvePackageOptions.packageName} should be resolved.\r\n   */\r\n  baseFolderPath: string;\r\n\r\n  /**\r\n   * If true, if the package name matches a Node.js system module, then the return\r\n   * value will be the package name without any path.\r\n   *\r\n   * @remarks\r\n   * This will take precedence over an installed NPM package of the same name.\r\n   *\r\n   * Example:\r\n   * ```ts\r\n   * // Returns the string \"fs\" indicating the Node.js system module\r\n   * Import.resolveModulePath({\r\n   *   resolvePath: \"fs\",\r\n   *   basePath: process.cwd()\r\n   * })\r\n   * ```\r\n   */\r\n  includeSystemModules?: boolean;\r\n\r\n  /**\r\n   * If true, then resolvePath is allowed to refer to the package.json of the active project.\r\n   *\r\n   * @remarks\r\n   * This will take precedence over any installed dependency with the same name.\r\n   * Note that this requires an additional PackageJsonLookup calculation.\r\n   *\r\n   * Example:\r\n   * ```ts\r\n   * // Returns an absolute path to the current package\r\n   * Import.resolveModulePath({\r\n   *   resolvePath: \"current-project\",\r\n   *   basePath: process.cwd(),\r\n   *   allowSelfReference: true\r\n   * })\r\n   * ```\r\n   */\r\n  allowSelfReference?: boolean;\r\n}\r\n\r\n/**\r\n * Options for {@link Import.resolveModule}\r\n * @public\r\n */\r\nexport interface IImportResolveModuleOptions extends IImportResolveOptions {\r\n  /**\r\n   * The module identifier to resolve. For example \"\\@rushstack/node-core-library\" or\r\n   * \"\\@rushstack/node-core-library/lib/index.js\"\r\n   */\r\n  modulePath: string;\r\n}\r\n\r\n/**\r\n * Options for {@link Import.resolvePackage}\r\n * @public\r\n */\r\nexport interface IImportResolvePackageOptions extends IImportResolveOptions {\r\n  /**\r\n   * The package name to resolve. For example \"\\@rushstack/node-core-library\"\r\n   */\r\n  packageName: string;\r\n}\r\n\r\ninterface IPackageDescriptor {\r\n  packageRootPath: string;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * Helpers for resolving and importing Node.js modules.\r\n * @public\r\n */\r\nexport class Import {\r\n  private static __builtInModules: Set<string> | undefined;\r\n  private static get _builtInModules(): Set<string> {\r\n    if (!Import.__builtInModules) {\r\n      Import.__builtInModules = new Set<string>(nodeModule.builtinModules);\r\n    }\r\n\r\n    return Import.__builtInModules;\r\n  }\r\n\r\n  /**\r\n   * Provides a way to improve process startup times by lazy-loading imported modules.\r\n   *\r\n   * @remarks\r\n   * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}\r\n   * package.  It enables you to replace an import like this:\r\n   *\r\n   * ```ts\r\n   * import * as example from 'example'; // <-- 100ms load time\r\n   *\r\n   * if (condition) {\r\n   *   example.doSomething();\r\n   * }\r\n   * ```\r\n   *\r\n   * ...with a pattern like this:\r\n   *\r\n   * ```ts\r\n   * const example: typeof import('example') = Import.lazy('example', require);\r\n   *\r\n   * if (condition) {\r\n   *   example.doSomething(); // <-- 100ms load time occurs here, only if needed\r\n   * }\r\n   * ```\r\n   *\r\n   * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus\r\n   * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,\r\n   * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.\r\n   *\r\n   * Usage guidelines:\r\n   *\r\n   * - Always specify types using `typeof` as shown above.\r\n   *\r\n   * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety\r\n   *   seriously impacts the maintainability of the code base.\r\n   *\r\n   * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:\r\n   *\r\n   * ```ts\r\n   * const example: typeof import('example') = Import.lazy('example', require);\r\n   * import type * as exampleTypes from 'example';\r\n   * ```\r\n   *\r\n   * - If the imported module confusingly has the same name as its export, then use the Module suffix:\r\n   *\r\n   * ```ts\r\n   * const exampleModule: typeof import('../../logic/Example') = Import.lazy(\r\n   *   '../../logic/Example', require);\r\n   * import type * as exampleTypes from '../../logic/Example';\r\n   * ```\r\n   *\r\n   * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted\r\n   *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function\r\n   *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is\r\n   *   better behaved.\r\n   *\r\n   * - It's recommended to sort imports in a standard ordering:\r\n   *\r\n   * ```ts\r\n   * // 1. external imports\r\n   * import * as path from 'path';\r\n   * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';\r\n   *\r\n   * // 2. local imports\r\n   * import { LocalFile } from './path/LocalFile';\r\n   *\r\n   * // 3. lazy-imports (which are technically variables, not imports)\r\n   * const semver: typeof import('semver') = Import.lazy('semver', require);\r\n   * ```\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  public static lazy(moduleName: string, require: (id: string) => unknown): any {\r\n    const importLazyLocal: (moduleName: string) => unknown = importLazy(require);\r\n    return importLazyLocal(moduleName);\r\n  }\r\n\r\n  /**\r\n   * This resolves a module path using similar logic as the Node.js `require.resolve()` API,\r\n   * but supporting extra features such as specifying the base folder.\r\n   *\r\n   * @remarks\r\n   * A module path is a text string that might appear in a statement such as\r\n   * `import { X } from \"____\";` or `const x = require(\"___\");`.  The implementation is based\r\n   * on the popular `resolve` NPM package.\r\n   *\r\n   * Suppose `example` is an NPM package whose entry point is `lib/index.js`:\r\n   * ```ts\r\n   * // Returns \"/path/to/project/node_modules/example/lib/index.js\"\r\n   * Import.resolveModule({ modulePath: 'example' });\r\n   *\r\n   * // Returns \"/path/to/project/node_modules/example/lib/other.js\"\r\n   * Import.resolveModule({ modulePath: 'example/lib/other' });\r\n   * ```\r\n   * If you need to determine the containing package folder\r\n   * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.\r\n   *\r\n   * @returns the absolute path of the resolved module.\r\n   * If {@link IImportResolveOptions.includeSystemModules} is specified\r\n   * and a system module is found, then its name is returned without any file path.\r\n   */\r\n  public static resolveModule(options: IImportResolveModuleOptions): string {\r\n    const { modulePath } = options;\r\n\r\n    if (path.isAbsolute(modulePath)) {\r\n      return modulePath;\r\n    }\r\n\r\n    const normalizedRootPath: string = FileSystem.getRealPath(options.baseFolderPath);\r\n\r\n    if (modulePath.startsWith('.')) {\r\n      // This looks like a conventional relative path\r\n      return path.resolve(normalizedRootPath, modulePath);\r\n    }\r\n\r\n    if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {\r\n      return modulePath;\r\n    }\r\n\r\n    if (options.allowSelfReference === true) {\r\n      const ownPackage: IPackageDescriptor | undefined = Import._getPackageName(options.baseFolderPath);\r\n      if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {\r\n        const packagePath: string = modulePath.substr(ownPackage.packageName.length + 1);\r\n        return path.resolve(ownPackage.packageRootPath, packagePath);\r\n      }\r\n    }\r\n\r\n    try {\r\n      return Resolve.sync(\r\n        // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package\r\n        options.includeSystemModules !== true && modulePath.indexOf('/') === -1\r\n          ? `${modulePath}/`\r\n          : modulePath,\r\n        {\r\n          basedir: normalizedRootPath,\r\n          preserveSymlinks: false\r\n        }\r\n      );\r\n    } catch (e) {\r\n      throw new Error(`Cannot find module \"${modulePath}\" from \"${options.baseFolderPath}\".`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Performs module resolution to determine the folder where a package is installed.\r\n   *\r\n   * @remarks\r\n   * Suppose `example` is an NPM package whose entry point is `lib/index.js`:\r\n   * ```ts\r\n   * // Returns \"/path/to/project/node_modules/example\"\r\n   * Import.resolvePackage({ packageName: 'example' });\r\n   * ```\r\n   *\r\n   * If you need to resolve a module path, use {@link Import.resolveModule} instead:\r\n   * ```ts\r\n   * // Returns \"/path/to/project/node_modules/example/lib/index.js\"\r\n   * Import.resolveModule({ modulePath: 'example' });\r\n   * ```\r\n   *\r\n   * @returns the absolute path of the package folder.\r\n   * If {@link IImportResolveOptions.includeSystemModules} is specified\r\n   * and a system module is found, then its name is returned without any file path.\r\n   */\r\n  public static resolvePackage(options: IImportResolvePackageOptions): string {\r\n    const { packageName } = options;\r\n\r\n    if (options.includeSystemModules && Import._builtInModules.has(packageName)) {\r\n      return packageName;\r\n    }\r\n\r\n    const normalizedRootPath: string = FileSystem.getRealPath(options.baseFolderPath);\r\n\r\n    if (options.allowSelfReference) {\r\n      const ownPackage: IPackageDescriptor | undefined = Import._getPackageName(options.baseFolderPath);\r\n      if (ownPackage && ownPackage.packageName === packageName) {\r\n        return ownPackage.packageRootPath;\r\n      }\r\n    }\r\n\r\n    try {\r\n      const resolvedPath: string = Resolve.sync(packageName, {\r\n        basedir: normalizedRootPath,\r\n        preserveSymlinks: false,\r\n        packageFilter: (pkg: { main: string }): { main: string } => {\r\n          // Hardwire \"main\" to point to a file that is guaranteed to exist.\r\n          // This helps resolve packages such as @types/node that have no entry point.\r\n          // And then we can use path.dirname() below to locate the package folder,\r\n          // even if the real entry point was in an subfolder with arbitrary nesting.\r\n          pkg.main = 'package.json';\r\n          return pkg;\r\n        }\r\n      });\r\n\r\n      const packagePath: string = path.dirname(resolvedPath);\r\n      const packageJson: IPackageJson = PackageJsonLookup.instance.loadPackageJson(\r\n        path.join(packagePath, 'package.json')\r\n      );\r\n      if (packageJson.name === packageName) {\r\n        return packagePath;\r\n      } else {\r\n        throw new Error();\r\n      }\r\n    } catch (e) {\r\n      throw new Error(`Cannot find package \"${packageName}\" from \"${options.baseFolderPath}\".`);\r\n    }\r\n  }\r\n\r\n  private static _getPackageName(rootPath: string): IPackageDescriptor | undefined {\r\n    const packageJsonPath: string | undefined = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(\r\n      rootPath\r\n    );\r\n    if (packageJsonPath) {\r\n      const packageJson: IPackageJson = PackageJsonLookup.instance.loadPackageJson(packageJsonPath);\r\n      return {\r\n        packageRootPath: path.dirname(packageJsonPath),\r\n        packageName: packageJson.name\r\n      };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n"]}