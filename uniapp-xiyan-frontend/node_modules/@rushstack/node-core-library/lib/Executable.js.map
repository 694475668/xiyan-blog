{"version":3,"file":"Executable.js","sourceRoot":"","sources":["../src/Executable.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as child_process from 'child_process';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport { EnvironmentMap } from './EnvironmentMap';\r\n\r\nimport { FileSystem } from './FileSystem';\r\nimport { PosixModeBits } from './PosixModeBits';\r\n\r\n/**\r\n * Typings for one of the streams inside IExecutableSpawnSyncOptions.stdio.\r\n * @public\r\n */\r\nexport type ExecutableStdioStreamMapping =\r\n  | 'pipe'\r\n  | 'ignore'\r\n  | 'inherit'\r\n  | NodeJS.WritableStream\r\n  | NodeJS.ReadableStream\r\n  | number\r\n  | undefined;\r\n\r\n/**\r\n * Types for {@link IExecutableSpawnSyncOptions.stdio}\r\n * and {@link IExecutableSpawnOptions.stdio}\r\n * @public\r\n */\r\nexport type ExecutableStdioMapping = 'pipe' | 'ignore' | 'inherit' | ExecutableStdioStreamMapping[];\r\n\r\n/**\r\n * Options for Executable.tryResolve().\r\n * @public\r\n */\r\nexport interface IExecutableResolveOptions {\r\n  /**\r\n   * The current working directory.  If omitted, process.cwd() will be used.\r\n   */\r\n  currentWorkingDirectory?: string;\r\n\r\n  /**\r\n   * The environment variables for the child process.\r\n   *\r\n   * @remarks\r\n   * If `environment` and `environmentMap` are both omitted, then `process.env` will be used.\r\n   * If `environment` and `environmentMap` cannot both be specified.\r\n   */\r\n  environment?: NodeJS.ProcessEnv;\r\n\r\n  /**\r\n   * The environment variables for the child process.\r\n   *\r\n   * @remarks\r\n   * If `environment` and `environmentMap` are both omitted, then `process.env` will be used.\r\n   * If `environment` and `environmentMap` cannot both be specified.\r\n   */\r\n  environmentMap?: EnvironmentMap;\r\n}\r\n\r\n/**\r\n * Options for {@link Executable.spawnSync}\r\n * @public\r\n */\r\nexport interface IExecutableSpawnSyncOptions extends IExecutableResolveOptions {\r\n  /**\r\n   * The content to be passed to the child process's stdin.\r\n   *\r\n   * NOTE: If specified, this content replaces any IExecutableSpawnSyncOptions.stdio[0]\r\n   * mapping for stdin.\r\n   */\r\n  input?: string;\r\n\r\n  /**\r\n   * The stdio mappings for the child process.\r\n   *\r\n   * NOTE: If IExecutableSpawnSyncOptions.input is provided, it will take precedence\r\n   * over the stdin mapping (stdio[0]).\r\n   */\r\n  stdio?: ExecutableStdioMapping;\r\n\r\n  /**\r\n   * The maximum time the process is allowed to run before it will be terminated.\r\n   */\r\n  timeoutMs?: number;\r\n\r\n  /**\r\n   * The largest amount of bytes allowed on stdout or stderr for this synchronous operation.\r\n   * If exceeded, the child process will be terminated.  The default is 200 * 1024.\r\n   */\r\n  maxBuffer?: number;\r\n}\r\n\r\n/**\r\n * Options for {@link Executable.spawn}\r\n * @public\r\n */\r\nexport interface IExecutableSpawnOptions extends IExecutableResolveOptions {\r\n  /**\r\n   * The stdio mappings for the child process.\r\n   *\r\n   * NOTE: If IExecutableSpawnSyncOptions.input is provided, it will take precedence\r\n   * over the stdin mapping (stdio[0]).\r\n   */\r\n  stdio?: ExecutableStdioMapping;\r\n}\r\n\r\n// Common environmental state used by Executable members\r\ninterface IExecutableContext {\r\n  currentWorkingDirectory: string;\r\n  environmentMap: EnvironmentMap;\r\n  // For Windows, the parsed PATHEXT environment variable\r\n  windowsExecutableExtensions: string[];\r\n}\r\n\r\ninterface ICommandLineFixup {\r\n  path: string;\r\n  args: string[];\r\n}\r\n\r\n/**\r\n * The Executable class provides a safe, portable, recommended solution for tools that need\r\n * to launch child processes.\r\n *\r\n * @remarks\r\n * The NodeJS child_process API provides a solution for launching child processes, however\r\n * its design encourages reliance on the operating system shell for certain features.\r\n * Invoking the OS shell is not safe, not portable, and generally not recommended:\r\n *\r\n * - Different shells have different behavior and command-line syntax, and which shell you\r\n *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be\r\n *   available on all platforms.\r\n *\r\n * - If a command parameter contains symbol characters, a shell may interpret them, which\r\n *   can introduce a security vulnerability\r\n *\r\n * - Each shell has different rules for escaping these symbols.  On Windows, the default\r\n *   shell is incapable of escaping certain character sequences.\r\n *\r\n * The Executable API provides a pure JavaScript implementation of primitive shell-like\r\n * functionality for searching the default PATH, appending default file extensions on Windows,\r\n * and executing a file that may contain a POSIX shebang.  This primitive functionality\r\n * is sufficient (and recommended) for most tooling scenarios.\r\n *\r\n * If you need additional shell features such as wildcard globbing, environment variable\r\n * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`\r\n * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is\r\n * guaranteed to work consistently across all platforms.\r\n *\r\n * @public\r\n */\r\nexport class Executable {\r\n  /**\r\n   * Synchronously create a child process and optionally capture its output.\r\n   *\r\n   * @remarks\r\n   * This function is similar to child_process.spawnSync().  The main differences are:\r\n   *\r\n   * - It does not invoke the OS shell unless the executable file is a shell script.\r\n   * - Command-line arguments containing special characters are more accurately passed\r\n   *   through to the child process.\r\n   * - If the filename is missing a path, then the shell's default PATH will be searched.\r\n   * - If the filename is missing a file extension, then Windows default file extensions\r\n   *   will be searched.\r\n   *\r\n   * @param filename - The name of the executable file.  This string must not contain any\r\n   * command-line arguments.  If the name contains any path delimiters, then the shell's\r\n   * default PATH will not be searched.\r\n   * @param args - The command-line arguments to be passed to the process.\r\n   * @param options - Additional options\r\n   * @returns the same data type as returned by the NodeJS child_process.spawnSync() API\r\n   *\r\n   * @privateRemarks\r\n   *\r\n   * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>\r\n   * polymorphically based on the options.encoding parameter value.  This is a fairly confusing\r\n   * design.  In most cases, developers want string with the default encoding.  If/when someone\r\n   * wants binary output or a non-default text encoding, we will introduce a separate API function\r\n   * with a name like \"spawnWithBufferSync\".\r\n   */\r\n  public static spawnSync(\r\n    filename: string,\r\n    args: string[],\r\n    options?: IExecutableSpawnSyncOptions\r\n  ): child_process.SpawnSyncReturns<string> {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const context: IExecutableContext = Executable._getExecutableContext(options);\r\n\r\n    const resolvedPath: string | undefined = Executable._tryResolve(filename, options, context);\r\n    if (!resolvedPath) {\r\n      throw new Error(`The executable file was not found: \"${filename}\"`);\r\n    }\r\n\r\n    const spawnOptions: child_process.SpawnSyncOptionsWithStringEncoding = {\r\n      cwd: context.currentWorkingDirectory,\r\n      env: context.environmentMap.toObject(),\r\n      input: options.input,\r\n      stdio: options.stdio as child_process.StdioOptions,\r\n      timeout: options.timeoutMs,\r\n      maxBuffer: options.maxBuffer,\r\n\r\n      // Contrary to what the NodeJS typings imply, we must explicitly specify \"utf8\" here\r\n      // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.\r\n      encoding: 'utf8',\r\n\r\n      // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.\r\n      shell: false\r\n    };\r\n\r\n    const normalizedCommandLine: ICommandLineFixup = Executable._buildCommandLineFixup(\r\n      resolvedPath,\r\n      args,\r\n      context\r\n    );\r\n\r\n    return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);\r\n  }\r\n\r\n  /**\r\n   * Start a child process.\r\n   *\r\n   * @remarks\r\n   * This function is similar to child_process.spawn().  The main differences are:\r\n   *\r\n   * - It does not invoke the OS shell unless the executable file is a shell script.\r\n   * - Command-line arguments containing special characters are more accurately passed\r\n   *   through to the child process.\r\n   * - If the filename is missing a path, then the shell's default PATH will be searched.\r\n   * - If the filename is missing a file extension, then Windows default file extensions\r\n   *   will be searched.\r\n   *\r\n   * This command is asynchronous, but it does not return a `Promise`.  Instead it returns\r\n   * a Node.js `ChildProcess` supporting event notifications.\r\n   *\r\n   * @param filename - The name of the executable file.  This string must not contain any\r\n   * command-line arguments.  If the name contains any path delimiters, then the shell's\r\n   * default PATH will not be searched.\r\n   * @param args - The command-line arguments to be passed to the process.\r\n   * @param options - Additional options\r\n   * @returns the same data type as returned by the NodeJS child_process.spawnSync() API\r\n   */\r\n  public static spawn(\r\n    filename: string,\r\n    args: string[],\r\n    options?: IExecutableSpawnOptions\r\n  ): child_process.ChildProcess {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const context: IExecutableContext = Executable._getExecutableContext(options);\r\n\r\n    const resolvedPath: string | undefined = Executable._tryResolve(filename, options, context);\r\n    if (!resolvedPath) {\r\n      throw new Error(`The executable file was not found: \"${filename}\"`);\r\n    }\r\n\r\n    const spawnOptions: child_process.SpawnOptions = {\r\n      cwd: context.currentWorkingDirectory,\r\n      env: context.environmentMap.toObject(),\r\n      stdio: options.stdio as child_process.StdioOptions,\r\n\r\n      // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.\r\n      shell: false\r\n    };\r\n\r\n    const normalizedCommandLine: ICommandLineFixup = Executable._buildCommandLineFixup(\r\n      resolvedPath,\r\n      args,\r\n      context\r\n    );\r\n\r\n    return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);\r\n  }\r\n\r\n  // PROBLEM: Given an \"args\" array of strings that may contain special characters (e.g. spaces,\r\n  // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array\r\n  // without anything getting corrupted along the way.\r\n  //\r\n  // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:\r\n  // - The Win32 CreateProcess() API expects the args to be encoded as a single text string\r\n  // - The decoding of this string is up to the application (not the OS), and there are 3 different\r\n  //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and\r\n  //   the Win32 CommandLineToArgvW()\r\n  // - The encodings are counterintuitive and have lots of special cases\r\n  // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used\r\n  //\r\n  // See these articles for a full analysis:\r\n  // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/\r\n  // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/\r\n  private static _buildCommandLineFixup(\r\n    resolvedPath: string,\r\n    args: string[],\r\n    context: IExecutableContext\r\n  ): ICommandLineFixup {\r\n    const fileExtension: string = path.extname(resolvedPath);\r\n\r\n    if (os.platform() === 'win32') {\r\n      // Do we need a custom handler for this file type?\r\n      switch (fileExtension.toUpperCase()) {\r\n        case '.EXE':\r\n        case '.COM':\r\n          // okay to execute directly\r\n          break;\r\n        case '.BAT':\r\n        case '.CMD': {\r\n          Executable._validateArgsForWindowsShell(args);\r\n\r\n          // These file types must be invoked via the Windows shell\r\n          let shellPath: string | undefined = context.environmentMap.get('COMSPEC');\r\n          if (!shellPath || !Executable._canExecute(shellPath, context)) {\r\n            shellPath = Executable.tryResolve('cmd.exe');\r\n          }\r\n          if (!shellPath) {\r\n            throw new Error(\r\n              `Unable to execute \"${path.basename(resolvedPath)}\" ` +\r\n                `because CMD.exe was not found in the PATH`\r\n            );\r\n          }\r\n\r\n          const shellArgs: string[] = [];\r\n          // /D: Disable execution of AutoRun commands when starting the new shell context\r\n          shellArgs.push('/d');\r\n          // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line\r\n          shellArgs.push('/s');\r\n          // /C: Execute the following command and then exit immediately\r\n          shellArgs.push('/c');\r\n\r\n          // If the path contains special charactrers (e.g. spaces), escape them so that\r\n          // they don't get interpreted by the shell\r\n          shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));\r\n          shellArgs.push(...args);\r\n\r\n          return { path: shellPath, args: shellArgs };\r\n        }\r\n        default:\r\n          throw new Error(\r\n            `Cannot execute \"${path.basename(resolvedPath)}\" because the file type is not supported`\r\n          );\r\n      }\r\n    }\r\n\r\n    return {\r\n      path: resolvedPath,\r\n      args: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Given a filename, this determines the absolute path of the executable file that would\r\n   * be executed by a shell:\r\n   *\r\n   * - If the filename is missing a path, then the shell's default PATH will be searched.\r\n   * - If the filename is missing a file extension, then Windows default file extensions\r\n   *   will be searched.\r\n   *\r\n   * @remarks\r\n   *\r\n   * @param filename - The name of the executable file.  This string must not contain any\r\n   * command-line arguments.  If the name contains any path delimiters, then the shell's\r\n   * default PATH will not be searched.\r\n   * @param options - optional other parameters\r\n   * @returns the absolute path of the executable, or undefined if it was not found\r\n   */\r\n  public static tryResolve(filename: string, options?: IExecutableResolveOptions): string | undefined {\r\n    return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));\r\n  }\r\n\r\n  private static _tryResolve(\r\n    filename: string,\r\n    options: IExecutableResolveOptions,\r\n    context: IExecutableContext\r\n  ): string | undefined {\r\n    // NOTE: Since \"filename\" cannot contain command-line arguments, the \"/\" here\r\n    // must be interpreted as a path delimiter\r\n    const hasPathSeparators: boolean =\r\n      filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\\\') >= 0);\r\n\r\n    // Are there any path separators?\r\n    if (hasPathSeparators) {\r\n      // If so, then don't search the PATH.  Just resolve relative to the current working directory\r\n      const resolvedPath: string = path.resolve(context.currentWorkingDirectory, filename);\r\n      return Executable._tryResolveFileExtension(resolvedPath, context);\r\n    } else {\r\n      // Otherwise if it's a bare name, then try everything in the shell PATH\r\n      const pathsToSearch: string[] = Executable._getSearchFolders(context);\r\n\r\n      for (const pathToSearch of pathsToSearch) {\r\n        const resolvedPath: string = path.join(pathToSearch, filename);\r\n        const result: string | undefined = Executable._tryResolveFileExtension(resolvedPath, context);\r\n        if (result) {\r\n          return result;\r\n        }\r\n      }\r\n\r\n      // No match was found\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  private static _tryResolveFileExtension(\r\n    resolvedPath: string,\r\n    context: IExecutableContext\r\n  ): string | undefined {\r\n    if (Executable._canExecute(resolvedPath, context)) {\r\n      return resolvedPath;\r\n    }\r\n\r\n    // Try the default file extensions\r\n    for (const shellExtension of context.windowsExecutableExtensions) {\r\n      const resolvedNameWithExtension: string = resolvedPath + shellExtension;\r\n\r\n      if (Executable._canExecute(resolvedNameWithExtension, context)) {\r\n        return resolvedNameWithExtension;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private static _buildEnvironmentMap(options: IExecutableResolveOptions): EnvironmentMap {\r\n    const environmentMap: EnvironmentMap = new EnvironmentMap();\r\n    if (options.environment !== undefined && options.environmentMap !== undefined) {\r\n      throw new Error(\r\n        'IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +\r\n          ' cannot both be specified'\r\n      );\r\n    }\r\n    if (options.environment !== undefined) {\r\n      environmentMap.mergeFromObject(options.environment);\r\n    } else if (options.environmentMap !== undefined) {\r\n      environmentMap.mergeFrom(options.environmentMap);\r\n    } else {\r\n      environmentMap.mergeFromObject(process.env);\r\n    }\r\n    return environmentMap;\r\n  }\r\n\r\n  /**\r\n   * This is used when searching the shell PATH for an executable, to determine\r\n   * whether a match should be skipped or not.  If it returns true, this does not\r\n   * guarantee that the file can be successfully executed.\r\n   */\r\n  private static _canExecute(filePath: string, context: IExecutableContext): boolean {\r\n    if (!FileSystem.exists(filePath)) {\r\n      return false;\r\n    }\r\n\r\n    if (os.platform() === 'win32') {\r\n      // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.\r\n      // That environment variable determines which extensions can be appended if the\r\n      // extension is missing, but it does not affect whether a file may be executed or not.\r\n      // Windows does have a (seldom used) ACL that can be used to deny execution permissions\r\n      // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.\r\n\r\n      // However, Windows *does* require that the file has some kind of file extension\r\n      if (path.extname(filePath) === '') {\r\n        return false;\r\n      }\r\n    } else {\r\n      // For Unix, check whether any of the POSIX execute bits are set\r\n      try {\r\n        // eslint-disable-next-line no-bitwise\r\n        if ((FileSystem.getPosixModeBits(filePath) & PosixModeBits.AllExecute) === 0) {\r\n          return false; // not executable\r\n        }\r\n      } catch (error) {\r\n        // If we have trouble accessing the file, ignore the error and consider it \"not executable\"\r\n        // since that's what a shell would do\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the list of folders where we will search for an executable,\r\n   * based on the PATH environment variable.\r\n   */\r\n  private static _getSearchFolders(context: IExecutableContext): string[] {\r\n    const pathList: string = context.environmentMap.get('PATH') || '';\r\n\r\n    const folders: string[] = [];\r\n\r\n    // Avoid processing duplicates\r\n    const seenPaths: Set<string> = new Set<string>();\r\n\r\n    // NOTE: Cmd.exe on Windows always searches the current working directory first.\r\n    // PowerShell and Unix shells do NOT do that, because it's a security concern.\r\n    // We follow their behavior.\r\n\r\n    for (const splitPath of pathList.split(path.delimiter)) {\r\n      const trimmedPath: string = splitPath.trim();\r\n      if (trimmedPath !== '') {\r\n        if (!seenPaths.has(trimmedPath)) {\r\n          // Fun fact: If you put relative paths in your PATH environment variable,\r\n          // all shells will dynamically match them against the current working directory.\r\n          // This is a terrible design, and in practice nobody does that, but it is supported...\r\n          // so we allow it here.\r\n          const resolvedPath: string = path.resolve(context.currentWorkingDirectory, trimmedPath);\r\n\r\n          if (!seenPaths.has(resolvedPath)) {\r\n            if (FileSystem.exists(resolvedPath)) {\r\n              folders.push(resolvedPath);\r\n            }\r\n\r\n            seenPaths.add(resolvedPath);\r\n          }\r\n\r\n          seenPaths.add(trimmedPath);\r\n        }\r\n      }\r\n    }\r\n\r\n    return folders;\r\n  }\r\n\r\n  private static _getExecutableContext(options: IExecutableResolveOptions | undefined): IExecutableContext {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    const environment: EnvironmentMap = Executable._buildEnvironmentMap(options);\r\n\r\n    let currentWorkingDirectory: string;\r\n    if (options.currentWorkingDirectory) {\r\n      currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);\r\n    } else {\r\n      currentWorkingDirectory = process.cwd();\r\n    }\r\n\r\n    const windowsExecutableExtensions: string[] = [];\r\n\r\n    if (os.platform() === 'win32') {\r\n      const pathExtVariable: string = environment.get('PATHEXT') || '';\r\n      for (const splitValue of pathExtVariable.split(';')) {\r\n        const trimmed: string = splitValue.trim().toLowerCase();\r\n        // Ignore malformed extensions\r\n        if (/^\\.[a-z0-9\\.]*[a-z0-9]$/i.test(trimmed)) {\r\n          // Don't add the same extension twice\r\n          if (windowsExecutableExtensions.indexOf(trimmed) < 0) {\r\n            windowsExecutableExtensions.push(trimmed);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      environmentMap: environment,\r\n      currentWorkingDirectory,\r\n      windowsExecutableExtensions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Given an input string containing special symbol characters, this inserts the \"^\" escape\r\n   * character to ensure the symbols are interpreted literally by the Windows shell.\r\n   */\r\n  private static _getEscapedForWindowsShell(text: string): string {\r\n    const escapableCharRegExp: RegExp = /[%\\^&|<> ]/g;\r\n    return text.replace(escapableCharRegExp, (value) => '^' + value);\r\n  }\r\n\r\n  /**\r\n   * Checks for characters that are unsafe to pass to a Windows batch file\r\n   * due to the way that cmd.exe implements escaping.\r\n   */\r\n  private static _validateArgsForWindowsShell(args: string[]): void {\r\n    const specialCharRegExp: RegExp = /[%\\^&|<>\\r\\n]/g;\r\n\r\n    for (const arg of args) {\r\n      const match: RegExpMatchArray | null = arg.match(specialCharRegExp);\r\n      if (match) {\r\n        // NOTE: It is possible to escape some of these characters by prefixing them\r\n        // with a caret (^), which allows these characters to be successfully passed\r\n        // through to the batch file %1 variables.  But they will be expanded again\r\n        // whenever they are used.  For example, NPM's binary wrapper batch files\r\n        // use \"%*\" to pass their arguments to Node.exe, which causes them to be expanded\r\n        // again.  Unfortunately the Cmd.exe batch language provides native escaping\r\n        // function (that could be used to insert the carets again).\r\n        //\r\n        // We could work around that by adding double carets, but in general there\r\n        // is no way to predict how many times the variable will get expanded.\r\n        // Thus, there is no generally reliable way to pass these characters.\r\n        throw new Error(\r\n          `The command line argument ${JSON.stringify(arg)} contains a` +\r\n            ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}