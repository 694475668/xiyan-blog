{"version":3,"file":"FileSystem.js","sourceRoot":"","sources":["../src/FileSystem.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as nodeJsPath from 'path';\r\nimport * as fs from 'fs';\r\nimport * as fsx from 'fs-extra';\r\n\r\nimport { Text, NewlineKind, Encoding } from './Text';\r\nimport { PosixModeBits } from './PosixModeBits';\r\n\r\n/**\r\n * An alias for the Node.js `fs.Stats` object.\r\n *\r\n * @remarks\r\n * This avoids the need to import the `fs` package when using the {@link FileSystem} API.\r\n * @public\r\n */\r\nexport type FileSystemStats = fs.Stats;\r\n\r\n// The PosixModeBits are intended to be used with bitwise operations.\r\n/* eslint-disable no-bitwise */\r\n\r\n/**\r\n * The options for {@link FileSystem.readFolder}\r\n * @public\r\n */\r\nexport interface IFileSystemReadFolderOptions {\r\n  /**\r\n   * If true, returns the absolute paths of the files in the folder.\r\n   * @defaultValue false\r\n   */\r\n  absolutePaths?: boolean;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.writeFile}\r\n * @public\r\n */\r\nexport interface IFileSystemWriteFileOptions {\r\n  /**\r\n   * If true, will ensure the folder is created before writing the file.\r\n   * @defaultValue false\r\n   */\r\n  ensureFolderExists?: boolean;\r\n\r\n  /**\r\n   * If specified, will normalize line endings to the specified style of newline.\r\n   * @defaultValue `undefined` which means no conversion will be performed\r\n   */\r\n  convertLineEndings?: NewlineKind;\r\n\r\n  /**\r\n   * If specified, will change the encoding of the file that will be written.\r\n   * @defaultValue \"utf8\"\r\n   */\r\n  encoding?: Encoding;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.readFile}\r\n * @public\r\n */\r\nexport interface IFileSystemReadFileOptions {\r\n  /**\r\n   * If specified, will change the encoding of the file that will be written.\r\n   * @defaultValue Encoding.Utf8\r\n   */\r\n  encoding?: Encoding;\r\n\r\n  /**\r\n   * If specified, will normalize line endings to the specified style of newline.\r\n   * @defaultValue `undefined` which means no conversion will be performed\r\n   */\r\n  convertLineEndings?: NewlineKind;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.move}\r\n * @public\r\n */\r\nexport interface IFileSystemMoveOptions {\r\n  /**\r\n   * The path of the existing object to be moved.\r\n   * The path may be absolute or relative.\r\n   */\r\n  sourcePath: string;\r\n\r\n  /**\r\n   * The new path for the object.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPath: string;\r\n\r\n  /**\r\n   * If true, will overwrite the file if it already exists.\r\n   * @defaultValue true\r\n   */\r\n  overwrite?: boolean;\r\n\r\n  /**\r\n   * If true, will ensure the folder is created before writing the file.\r\n   * @defaultValue false\r\n   */\r\n  ensureFolderExists?: boolean;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFileBaseOptions {\r\n  /**\r\n   * The path of the existing object to be copied.\r\n   * The path may be absolute or relative.\r\n   */\r\n  sourcePath: string;\r\n\r\n  /**\r\n   * Specifies what to do if the target object already exists.\r\n   * @defaultValue {@link AlreadyExistsBehavior.Overwrite}\r\n   */\r\n  alreadyExistsBehavior?: AlreadyExistsBehavior;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.copyFile}\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFileOptions extends IFileSystemCopyFileBaseOptions {\r\n  /**\r\n   * The path that the object will be copied to.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPath: string;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.copyFile}\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFileToManyOptions extends IFileSystemCopyFileBaseOptions {\r\n  /**\r\n   * The path that the object will be copied to.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPaths: string[];\r\n}\r\n\r\n/**\r\n * Specifies the behavior of {@link FileSystem.copyFiles} in a situation where the target object\r\n * already exists.\r\n * @public\r\n */\r\nexport const enum AlreadyExistsBehavior {\r\n  /**\r\n   * If the destination object exists, overwrite it.\r\n   * This is the default behavior for {@link FileSystem.copyFiles}.\r\n   */\r\n  Overwrite = 'overwrite',\r\n\r\n  /**\r\n   * If the destination object exists, report an error.\r\n   */\r\n  Error = 'error',\r\n\r\n  /**\r\n   * If the destination object exists, skip it and continue the operation.\r\n   */\r\n  Ignore = 'ignore'\r\n}\r\n\r\n/**\r\n * Callback function type for {@link IFileSystemCopyFilesAsyncOptions.filter}\r\n * @public\r\n */\r\nexport type FileSystemCopyFilesAsyncFilter = (\r\n  sourcePath: string,\r\n  destinationPath: string\r\n) => Promise<boolean>;\r\n\r\n/**\r\n * Callback function type for {@link IFileSystemCopyFilesOptions.filter}\r\n * @public\r\n */\r\nexport type FileSystemCopyFilesFilter = (sourcePath: string, destinationPath: string) => boolean;\r\n\r\n/**\r\n * The options for {@link FileSystem.copyFilesAsync}\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFilesAsyncOptions {\r\n  /**\r\n   * The starting path of the file or folder to be copied.\r\n   * The path may be absolute or relative.\r\n   */\r\n  sourcePath: string;\r\n\r\n  /**\r\n   * The path that the files will be copied to.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPath: string;\r\n\r\n  /**\r\n   * If true, then when copying symlinks, copy the target object instead of copying the link.\r\n   */\r\n  dereferenceSymlinks?: boolean;\r\n\r\n  /**\r\n   * Specifies what to do if the target object already exists.\r\n   */\r\n  alreadyExistsBehavior?: AlreadyExistsBehavior;\r\n\r\n  /**\r\n   * If true, then the target object will be assigned \"last modification\" and \"last access\" timestamps\r\n   * that are the same as the source.  Otherwise, the OS default timestamps are assigned.\r\n   */\r\n  preserveTimestamps?: boolean;\r\n\r\n  /**\r\n   * A callback that will be invoked for each path that is copied.  The callback can return `false`\r\n   * to cause the object to be excluded from the operation.\r\n   */\r\n  filter?: FileSystemCopyFilesAsyncFilter | FileSystemCopyFilesFilter;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.copyFiles}\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFilesOptions extends IFileSystemCopyFilesAsyncOptions {\r\n  /**  {@inheritdoc IFileSystemCopyFilesAsyncOptions.filter} */\r\n  filter?: FileSystemCopyFilesFilter; // narrow the type to exclude FileSystemCopyFilesAsyncFilter\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.deleteFile}\r\n * @public\r\n */\r\nexport interface IFileSystemDeleteFileOptions {\r\n  /**\r\n   * If true, will throw an exception if the file did not exist before `deleteFile()` was called.\r\n   * @defaultValue false\r\n   */\r\n  throwIfNotExists?: boolean;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.updateTimes}\r\n * Both times must be specified.\r\n * @public\r\n */\r\nexport interface IFileSystemUpdateTimeParameters {\r\n  /**\r\n   * The POSIX epoch time or Date when this was last accessed.\r\n   */\r\n  accessedTime: number | Date;\r\n\r\n  /**\r\n   * The POSIX epoch time or Date when this was last modified\r\n   */\r\n  modifiedTime: number | Date;\r\n}\r\n\r\n/**\r\n * The options for {@link FileSystem.createSymbolicLinkJunction}, {@link FileSystem.createSymbolicLinkFile},\r\n * {@link FileSystem.createSymbolicLinkFolder}, and {@link FileSystem.createHardLink}.\r\n *\r\n * @public\r\n */\r\nexport interface IFileSystemCreateLinkOptions {\r\n  /**\r\n   * The existing path that the symbolic link will point to.\r\n   */\r\n  linkTargetPath: string;\r\n\r\n  /**\r\n   * The new path for the new symlink link to be created.\r\n   */\r\n  newLinkPath: string;\r\n\r\n  /**\r\n   * Specifies what to do if the target object already exists. Defaults to `AlreadyExistsBehavior.Error`.\r\n   */\r\n  alreadyExistsBehavior?: AlreadyExistsBehavior;\r\n}\r\n\r\nconst MOVE_DEFAULT_OPTIONS: Partial<IFileSystemMoveOptions> = {\r\n  overwrite: true,\r\n  ensureFolderExists: false\r\n};\r\n\r\nconst READ_FOLDER_DEFAULT_OPTIONS: Partial<IFileSystemReadFolderOptions> = {\r\n  absolutePaths: false\r\n};\r\n\r\nconst WRITE_FILE_DEFAULT_OPTIONS: Partial<IFileSystemWriteFileOptions> = {\r\n  ensureFolderExists: false,\r\n  convertLineEndings: undefined,\r\n  encoding: Encoding.Utf8\r\n};\r\n\r\nconst APPEND_TO_FILE_DEFAULT_OPTIONS: Partial<IFileSystemWriteFileOptions> = {\r\n  ...WRITE_FILE_DEFAULT_OPTIONS\r\n};\r\n\r\nconst READ_FILE_DEFAULT_OPTIONS: Partial<IFileSystemReadFileOptions> = {\r\n  encoding: Encoding.Utf8,\r\n  convertLineEndings: undefined\r\n};\r\n\r\nconst COPY_FILE_DEFAULT_OPTIONS: Partial<IFileSystemCopyFileOptions> = {\r\n  alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\r\n};\r\n\r\nconst COPY_FILES_DEFAULT_OPTIONS: Partial<IFileSystemCopyFilesOptions> = {\r\n  alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\r\n};\r\n\r\nconst DELETE_FILE_DEFAULT_OPTIONS: Partial<IFileSystemDeleteFileOptions> = {\r\n  throwIfNotExists: false\r\n};\r\n\r\n/**\r\n * The FileSystem API provides a complete set of recommended operations for interacting with the file system.\r\n *\r\n * @remarks\r\n * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level\r\n * primitives that must be mapped for each supported operating system. The FileSystem API takes a\r\n * philosophical approach of providing \"one obvious way\" to do each operation. We also prefer synchronous\r\n * operations except in cases where there would be a clear performance benefit for using async, since synchronous\r\n * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen\r\n * performance, versus improving it.\r\n *\r\n * Note that in the documentation, we refer to \"filesystem objects\", this can be a\r\n * file, folder, symbolic link, hard link, directory junction, etc.\r\n *\r\n * @public\r\n */\r\nexport class FileSystem {\r\n  // ===============\r\n  // COMMON OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Returns true if the path exists on disk.\r\n   * Behind the scenes it uses `fs.existsSync()`.\r\n   * @remarks\r\n   * There is a debate about the fact that after `fs.existsSync()` returns true,\r\n   * the file might be deleted before fs.readSync() is called, which would imply that everybody\r\n   * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.\r\n   * We find this to be unpersuasive, since \"unexceptional exceptions\" really hinder the\r\n   * break-on-exception debugging experience. Also, throwing/catching is generally slow.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static exists(path: string): boolean {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.existsSync(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.exists}.\r\n   */\r\n  public static async existsAsync(path: string): Promise<boolean> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return new Promise<boolean>((resolve: (result: boolean) => void) => {\r\n        fsx.exists(path, resolve);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the statistics for a particular filesystem object.\r\n   * If the path is a link, this function follows the link and returns statistics about the link target.\r\n   * Behind the scenes it uses `fs.statSync()`.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static getStatistics(path: string): FileSystemStats {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.statSync(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.getStatistics}.\r\n   */\r\n  public static async getStatisticsAsync(path: string): Promise<FileSystemStats> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.stat(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates the accessed and modified timestamps of the filesystem object referenced by path.\r\n   * Behind the scenes it uses `fs.utimesSync()`.\r\n   * The caller should specify both times in the `times` parameter.\r\n   * @param path - The path of the file that should be modified.\r\n   * @param times - The times that the object should be updated to reflect.\r\n   */\r\n  public static updateTimes(path: string, times: IFileSystemUpdateTimeParameters): void {\r\n    return FileSystem._wrapException(() => {\r\n      fsx.utimesSync(path, times.accessedTime, times.modifiedTime);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.updateTimes}.\r\n   */\r\n  public static async updateTimesAsync(path: string, times: IFileSystemUpdateTimeParameters): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      // This cast is needed because the fs-extra typings require both parameters\r\n      // to have the same type (number or Date), whereas Node.js does not require that.\r\n      return fsx.utimes(path, times.accessedTime as number, times.modifiedTime as number);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Changes the permissions (i.e. file mode bits) for a filesystem object.\r\n   * Behind the scenes it uses `fs.chmodSync()`.\r\n   * @param path - The absolute or relative path to the object that should be updated.\r\n   * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\r\n   */\r\n  public static changePosixModeBits(path: string, mode: PosixModeBits): void {\r\n    FileSystem._wrapException(() => {\r\n      fs.chmodSync(path, mode);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.changePosixModeBits}.\r\n   */\r\n  public static async changePosixModeBitsAsync(path: string, mode: PosixModeBits): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.chmod(path, mode);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieves the permissions (i.e. file mode bits) for a filesystem object.\r\n   * Behind the scenes it uses `fs.chmodSync()`.\r\n   * @param path - The absolute or relative path to the object that should be updated.\r\n   *\r\n   * @remarks\r\n   * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.\r\n   * If statistics in addition to the mode bits are needed, it is more efficient\r\n   * to call {@link FileSystem.getStatistics} directly instead.\r\n   */\r\n  public static getPosixModeBits(path: string): PosixModeBits {\r\n    return FileSystem._wrapException(() => {\r\n      return FileSystem.getStatistics(path).mode;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.getPosixModeBits}.\r\n   */\r\n  public static async getPosixModeBitsAsync(path: string): Promise<PosixModeBits> {\r\n    return await FileSystem._wrapExceptionAsync(async () => {\r\n      return (await FileSystem.getStatisticsAsync(path)).mode;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a 10-character string representation of a PosixModeBits value similar to what\r\n   * would be displayed by a command such as \"ls -l\" on a POSIX-like operating system.\r\n   * @remarks\r\n   * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as \"-rw-rw-rw-\".\r\n   * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\r\n   */\r\n  public static formatPosixModeBits(modeBits: PosixModeBits): string {\r\n    let result: string = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)\r\n\r\n    result += modeBits & PosixModeBits.UserRead ? 'r' : '-';\r\n    result += modeBits & PosixModeBits.UserWrite ? 'w' : '-';\r\n    result += modeBits & PosixModeBits.UserExecute ? 'x' : '-';\r\n\r\n    result += modeBits & PosixModeBits.GroupRead ? 'r' : '-';\r\n    result += modeBits & PosixModeBits.GroupWrite ? 'w' : '-';\r\n    result += modeBits & PosixModeBits.GroupExecute ? 'x' : '-';\r\n\r\n    result += modeBits & PosixModeBits.OthersRead ? 'r' : '-';\r\n    result += modeBits & PosixModeBits.OthersWrite ? 'w' : '-';\r\n    result += modeBits & PosixModeBits.OthersExecute ? 'x' : '-';\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.\r\n   * Behind the scenes it uses `fs-extra.moveSync()`\r\n   */\r\n  public static move(options: IFileSystemMoveOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      options = {\r\n        ...MOVE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      try {\r\n        fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(options.destinationPath);\r\n          FileSystem.ensureFolder(folderPath);\r\n          fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.move}.\r\n   */\r\n  public static async moveAsync(options: IFileSystemMoveOptions): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...MOVE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      try {\r\n        await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(options.destinationPath);\r\n          await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));\r\n          await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // ===============\r\n  // FOLDER OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Recursively creates a folder at a given path.\r\n   * Behind the scenes is uses `fs-extra.ensureDirSync()`.\r\n   * @remarks\r\n   * Throws an exception if anything in the folderPath is not a folder.\r\n   * @param folderPath - The absolute or relative path of the folder which should be created.\r\n   */\r\n  public static ensureFolder(folderPath: string): void {\r\n    FileSystem._wrapException(() => {\r\n      fsx.ensureDirSync(folderPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.ensureFolder}.\r\n   */\r\n  public static async ensureFolderAsync(folderPath: string): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.ensureDir(folderPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of the folder, not including \".\" or \"..\".\r\n   * Behind the scenes it uses `fs.readdirSync()`.\r\n   * @param folderPath - The absolute or relative path to the folder which should be read.\r\n   * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`\r\n   */\r\n  public static readFolder(folderPath: string, options?: IFileSystemReadFolderOptions): string[] {\r\n    return FileSystem._wrapException(() => {\r\n      options = {\r\n        ...READ_FOLDER_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8\r\n      const fileNames: string[] = fsx.readdirSync(folderPath);\r\n      if (options.absolutePaths) {\r\n        return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));\r\n      } else {\r\n        return fileNames;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.readFolder}.\r\n   */\r\n  public static async readFolderAsync(\r\n    folderPath: string,\r\n    options?: IFileSystemReadFolderOptions\r\n  ): Promise<string[]> {\r\n    return await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...READ_FOLDER_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8\r\n      const fileNames: string[] = await fsx.readdir(folderPath);\r\n      if (options.absolutePaths) {\r\n        return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));\r\n      } else {\r\n        return fileNames;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a folder, including all of its contents.\r\n   * Behind the scenes is uses `fs-extra.removeSync()`.\r\n   * @remarks\r\n   * Does not throw if the folderPath does not exist.\r\n   * @param folderPath - The absolute or relative path to the folder which should be deleted.\r\n   */\r\n  public static deleteFolder(folderPath: string): void {\r\n    FileSystem._wrapException(() => {\r\n      fsx.removeSync(folderPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.deleteFolder}.\r\n   */\r\n  public static async deleteFolderAsync(folderPath: string): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.remove(folderPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.\r\n   * Behind the scenes it uses `fs-extra.emptyDirSync()`.\r\n   * @remarks\r\n   * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder\r\n   * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.\r\n   * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.\r\n   */\r\n  public static ensureEmptyFolder(folderPath: string): void {\r\n    FileSystem._wrapException(() => {\r\n      fsx.emptyDirSync(folderPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.ensureEmptyFolder}.\r\n   */\r\n  public static async ensureEmptyFolderAsync(folderPath: string): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.emptyDir(folderPath);\r\n    });\r\n  }\r\n\r\n  // ===============\r\n  // FILE OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Writes a text string to a file on disk, overwriting the file if it already exists.\r\n   * Behind the scenes it uses `fs.writeFileSync()`.\r\n   * @remarks\r\n   * Throws an error if the folder doesn't exist, unless ensureFolder=true.\r\n   * @param filePath - The absolute or relative path of the file.\r\n   * @param contents - The text that should be written to the file.\r\n   * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\r\n   */\r\n  public static writeFile(\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions\r\n  ): void {\r\n    FileSystem._wrapException(() => {\r\n      options = {\r\n        ...WRITE_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents.toString(), options.convertLineEndings);\r\n      }\r\n\r\n      try {\r\n        fsx.writeFileSync(filePath, contents, { encoding: options.encoding });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(filePath);\r\n          FileSystem.ensureFolder(folderPath);\r\n          fsx.writeFileSync(filePath, contents, { encoding: options.encoding });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.writeFile}.\r\n   */\r\n  public static async writeFileAsync(\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions\r\n  ): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...WRITE_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents.toString(), options.convertLineEndings);\r\n      }\r\n\r\n      try {\r\n        await fsx.writeFile(filePath, contents, { encoding: options.encoding });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(filePath);\r\n          await FileSystem.ensureFolderAsync(folderPath);\r\n          await fsx.writeFile(filePath, contents, { encoding: options.encoding });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes a text string to a file on disk, appending to the file if it already exists.\r\n   * Behind the scenes it uses `fs.appendFileSync()`.\r\n   * @remarks\r\n   * Throws an error if the folder doesn't exist, unless ensureFolder=true.\r\n   * @param filePath - The absolute or relative path of the file.\r\n   * @param contents - The text that should be written to the file.\r\n   * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\r\n   */\r\n  public static appendToFile(\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions\r\n  ): void {\r\n    FileSystem._wrapException(() => {\r\n      options = {\r\n        ...APPEND_TO_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents.toString(), options.convertLineEndings);\r\n      }\r\n\r\n      try {\r\n        fsx.appendFileSync(filePath, contents, { encoding: options.encoding });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(filePath);\r\n          FileSystem.ensureFolder(folderPath);\r\n          fsx.appendFileSync(filePath, contents, { encoding: options.encoding });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.appendToFile}.\r\n   */\r\n  public static async appendToFileAsync(\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions\r\n  ): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...APPEND_TO_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents.toString(), options.convertLineEndings);\r\n      }\r\n\r\n      try {\r\n        await fsx.appendFile(filePath, contents, { encoding: options.encoding });\r\n      } catch (error) {\r\n        if (options.ensureFolderExists) {\r\n          if (!FileSystem.isNotExistError(error)) {\r\n            throw error;\r\n          }\r\n\r\n          const folderPath: string = nodeJsPath.dirname(filePath);\r\n          await FileSystem.ensureFolderAsync(folderPath);\r\n          await fsx.appendFile(filePath, contents, { encoding: options.encoding });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of a file into a string.\r\n   * Behind the scenes it uses `fs.readFileSync()`.\r\n   * @param filePath - The relative or absolute path to the file whose contents should be read.\r\n   * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`\r\n   */\r\n  public static readFile(filePath: string, options?: IFileSystemReadFileOptions): string {\r\n    return FileSystem._wrapException(() => {\r\n      options = {\r\n        ...READ_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      let contents: string = FileSystem.readFileToBuffer(filePath).toString(options.encoding);\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents, options.convertLineEndings);\r\n      }\r\n\r\n      return contents;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.readFile}.\r\n   */\r\n  public static async readFileAsync(filePath: string, options?: IFileSystemReadFileOptions): Promise<string> {\r\n    return await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...READ_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      let contents: string = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);\r\n      if (options.convertLineEndings) {\r\n        contents = Text.convertTo(contents, options.convertLineEndings);\r\n      }\r\n\r\n      return contents;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of a file into a buffer.\r\n   * Behind the scenes is uses `fs.readFileSync()`.\r\n   * @param filePath - The relative or absolute path to the file whose contents should be read.\r\n   */\r\n  public static readFileToBuffer(filePath: string): Buffer {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.readFileSync(filePath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.readFileToBuffer}.\r\n   */\r\n  public static async readFileToBufferAsync(filePath: string): Promise<Buffer> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.readFile(filePath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Copies a single file from one location to another.\r\n   * By default, destinationPath is overwritten if it already exists.\r\n   *\r\n   * @remarks\r\n   * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.\r\n   * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.\r\n   *\r\n   * The implementation is based on `copySync()` from the `fs-extra` package.\r\n   */\r\n  public static copyFile(options: IFileSystemCopyFileOptions): void {\r\n    options = {\r\n      ...COPY_FILE_DEFAULT_OPTIONS,\r\n      ...options\r\n    };\r\n\r\n    if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {\r\n      throw new Error(\r\n        'The specified path refers to a folder; this operation expects a file object:\\n' + options.sourcePath\r\n      );\r\n    }\r\n\r\n    FileSystem._wrapException(() => {\r\n      fsx.copySync(options.sourcePath, options.destinationPath, {\r\n        errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,\r\n        overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.copyFile}.\r\n   */\r\n  public static async copyFileAsync(options: IFileSystemCopyFileOptions): Promise<void> {\r\n    options = {\r\n      ...COPY_FILE_DEFAULT_OPTIONS,\r\n      ...options\r\n    };\r\n\r\n    if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {\r\n      throw new Error(\r\n        'The specified path refers to a folder; this operation expects a file object:\\n' + options.sourcePath\r\n      );\r\n    }\r\n\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.copy(options.sourcePath, options.destinationPath, {\r\n        errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,\r\n        overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Copies a single file from one location to one or more other locations.\r\n   * By default, the file at the destination is overwritten if it already exists.\r\n   *\r\n   * @remarks\r\n   * The `copyFileToManyAsync()` API cannot be used to copy folders.  It copies at most one file.\r\n   *\r\n   * The implementation is based on `createReadStream()` and `createWriteStream()` from the\r\n   * `fs-extra` package.\r\n   */\r\n  public static async copyFileToManyAsync(options: IFileSystemCopyFileToManyOptions): Promise<void> {\r\n    options = {\r\n      ...COPY_FILE_DEFAULT_OPTIONS,\r\n      ...options\r\n    };\r\n\r\n    if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {\r\n      throw new Error(\r\n        'The specified path refers to a folder; this operation expects a file path:\\n' + options.sourcePath\r\n      );\r\n    }\r\n\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      // See flags documentation: https://nodejs.org/api/fs.html#fs_file_system_flags\r\n      const writeFlags: string[] = [];\r\n      switch (options.alreadyExistsBehavior) {\r\n        case AlreadyExistsBehavior.Error:\r\n        case AlreadyExistsBehavior.Ignore:\r\n          writeFlags.push('wx');\r\n          break;\r\n        case AlreadyExistsBehavior.Overwrite:\r\n        default:\r\n          writeFlags.push('w');\r\n      }\r\n      const flags: string = writeFlags.join();\r\n\r\n      const createPipePromise: (sourceStream: fs.ReadStream, destinationPath: string) => Promise<void> = (\r\n        sourceStream: fs.ReadStream,\r\n        destinationPath: string\r\n      ) => {\r\n        return new Promise((resolve: () => void, reject: (error: Error) => void) => {\r\n          const destinationStream: fs.WriteStream = fs.createWriteStream(destinationPath);\r\n          const streamsToDestroy: fs.WriteStream[] = [destinationStream];\r\n          sourceStream.on('error', (e: Error) => {\r\n            for (const streamToDestroy of streamsToDestroy) {\r\n              streamToDestroy.destroy();\r\n            }\r\n            reject(e);\r\n          });\r\n          sourceStream\r\n            .pipe(destinationStream)\r\n            .on('close', () => {\r\n              resolve();\r\n            })\r\n            .on('error', (e: Error) => {\r\n              if (FileSystem.isNotExistError(e)) {\r\n                destinationStream.destroy();\r\n                FileSystem.ensureFolder(nodeJsPath.dirname(destinationStream.path as string));\r\n                const retryDestinationStream: fs.WriteStream = fsx.createWriteStream(destinationPath, {\r\n                  flags\r\n                });\r\n                streamsToDestroy.push(retryDestinationStream);\r\n                sourceStream\r\n                  .pipe(retryDestinationStream)\r\n                  .on('close', () => {\r\n                    resolve();\r\n                  })\r\n                  .on('error', (e2: Error) => {\r\n                    reject(e2);\r\n                  });\r\n              } else if (\r\n                options.alreadyExistsBehavior === AlreadyExistsBehavior.Ignore &&\r\n                FileSystem.isErrnoException(e) &&\r\n                e.code === 'EEXIST'\r\n              ) {\r\n                resolve();\r\n              } else {\r\n                reject(e);\r\n              }\r\n            });\r\n        });\r\n      };\r\n\r\n      const sourceStream: fs.ReadStream = fsx.createReadStream(options.sourcePath);\r\n      const uniqueDestinationPaths: Set<string> = new Set(options.destinationPaths);\r\n      const pipePromises: Promise<void>[] = [];\r\n      for (const destinationPath of uniqueDestinationPaths) {\r\n        pipePromises.push(createPipePromise(sourceStream, destinationPath));\r\n      }\r\n\r\n      await Promise.all(pipePromises);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Copies a file or folder from one location to another, recursively copying any folder contents.\r\n   * By default, destinationPath is overwritten if it already exists.\r\n   *\r\n   * @remarks\r\n   * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}\r\n   * instead to more clearly communicate the intended operation.\r\n   *\r\n   * The implementation is based on `copySync()` from the `fs-extra` package.\r\n   */\r\n  public static copyFiles(options: IFileSystemCopyFilesOptions): void {\r\n    options = {\r\n      ...COPY_FILES_DEFAULT_OPTIONS,\r\n      ...options\r\n    };\r\n\r\n    FileSystem._wrapException(() => {\r\n      fsx.copySync(options.sourcePath, options.destinationPath, {\r\n        dereference: !!options.dereferenceSymlinks,\r\n        errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,\r\n        overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,\r\n        preserveTimestamps: !!options.preserveTimestamps,\r\n        filter: options.filter\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.copyFiles}.\r\n   */\r\n  public static async copyFilesAsync(options: IFileSystemCopyFilesOptions): Promise<void> {\r\n    options = {\r\n      ...COPY_FILES_DEFAULT_OPTIONS,\r\n      ...options\r\n    };\r\n\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      fsx.copySync(options.sourcePath, options.destinationPath, {\r\n        dereference: !!options.dereferenceSymlinks,\r\n        errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,\r\n        overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,\r\n        preserveTimestamps: !!options.preserveTimestamps,\r\n        filter: options.filter\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a file. Can optionally throw if the file doesn't exist.\r\n   * Behind the scenes it uses `fs.unlinkSync()`.\r\n   * @param filePath - The absolute or relative path to the file that should be deleted.\r\n   * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`\r\n   */\r\n  public static deleteFile(filePath: string, options?: IFileSystemDeleteFileOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      options = {\r\n        ...DELETE_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      try {\r\n        fsx.unlinkSync(filePath);\r\n      } catch (error) {\r\n        if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.deleteFile}.\r\n   */\r\n  public static async deleteFileAsync(\r\n    filePath: string,\r\n    options?: IFileSystemDeleteFileOptions\r\n  ): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      options = {\r\n        ...DELETE_FILE_DEFAULT_OPTIONS,\r\n        ...options\r\n      };\r\n\r\n      try {\r\n        await fsx.unlink(filePath);\r\n      } catch (error) {\r\n        if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // ===============\r\n  // LINK OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Gets the statistics of a filesystem object. Does NOT follow the link to its target.\r\n   * Behind the scenes it uses `fs.lstatSync()`.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static getLinkStatistics(path: string): FileSystemStats {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.lstatSync(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.getLinkStatistics}.\r\n   */\r\n  public static async getLinkStatisticsAsync(path: string): Promise<FileSystemStats> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.lstat(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * If `path` refers to a symbolic link, this returns the path of the link target, which may be\r\n   * an absolute or relative path.\r\n   *\r\n   * @remarks\r\n   * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown\r\n   * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.\r\n   *\r\n   * @param path - The absolute or relative path to the symbolic link.\r\n   * @returns the path of the link target\r\n   */\r\n  public static readLink(path: string): string {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.readlinkSync(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.readLink}.\r\n   */\r\n  public static async readLinkAsync(path: string): Promise<string> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.readlink(path);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a Windows \"directory junction\". Behaves like `createSymbolicLinkToFile()` on other platforms.\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkJunction(options: IFileSystemCreateLinkOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      // For directories, we use a Windows \"junction\".  On POSIX operating systems, this produces a regular symlink.\r\n      fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.createSymbolicLinkJunction}.\r\n   */\r\n  public static async createSymbolicLinkJunctionAsync(options: IFileSystemCreateLinkOptions): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      // For directories, we use a Windows \"junction\".  On POSIX operating systems, this produces a regular symlink.\r\n      return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a symbolic link to a file (on Windows this requires elevated permissionsBits).\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkFile(options: IFileSystemCreateLinkOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.createSymbolicLinkFile}.\r\n   */\r\n  public static async createSymbolicLinkFileAsync(options: IFileSystemCreateLinkOptions): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a symbolic link to a folder (on Windows this requires elevated permissionsBits).\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkFolder(options: IFileSystemCreateLinkOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.createSymbolicLinkFolder}.\r\n   */\r\n  public static async createSymbolicLinkFolderAsync(options: IFileSystemCreateLinkOptions): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a hard link.\r\n   * Behind the scenes it uses `fs.linkSync()`.\r\n   */\r\n  public static createHardLink(options: IFileSystemCreateLinkOptions): void {\r\n    FileSystem._wrapException(() => {\r\n      try {\r\n        fsx.linkSync(options.linkTargetPath, options.newLinkPath);\r\n      } catch (error) {\r\n        if (error.code === 'EEXIST') {\r\n          switch (options.alreadyExistsBehavior) {\r\n            case AlreadyExistsBehavior.Ignore:\r\n              return;\r\n            case AlreadyExistsBehavior.Overwrite:\r\n              this.deleteFile(options.newLinkPath);\r\n              break;\r\n            case AlreadyExistsBehavior.Error:\r\n            default:\r\n              throw error;\r\n          }\r\n        } else {\r\n          const linkTargetExists: boolean = FileSystem.exists(options.linkTargetPath);\r\n          if (FileSystem.isNotExistError(error) && linkTargetExists) {\r\n            this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));\r\n            this.createHardLink(options);\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.createHardLink}.\r\n   */\r\n  public static async createHardLinkAsync(options: IFileSystemCreateLinkOptions): Promise<void> {\r\n    await FileSystem._wrapExceptionAsync(async () => {\r\n      try {\r\n        await fsx.link(options.linkTargetPath, options.newLinkPath);\r\n      } catch (error) {\r\n        if (error.code === 'EEXIST') {\r\n          switch (options.alreadyExistsBehavior) {\r\n            case AlreadyExistsBehavior.Ignore:\r\n              return;\r\n            case AlreadyExistsBehavior.Overwrite:\r\n              await this.deleteFileAsync(options.newLinkPath);\r\n              break;\r\n            case AlreadyExistsBehavior.Error:\r\n            default:\r\n              throw error;\r\n          }\r\n        } else {\r\n          const linkTargetExists: boolean = await FileSystem.exists(options.linkTargetPath);\r\n          if (FileSystem.isNotExistError(error) && linkTargetExists) {\r\n            await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));\r\n            await this.createHardLinkAsync(options);\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Follows a link to its destination and returns the absolute path to the final target of the link.\r\n   * Behind the scenes it uses `fs.realpathSync()`.\r\n   * @param linkPath - The path to the link.\r\n   */\r\n  public static getRealPath(linkPath: string): string {\r\n    return FileSystem._wrapException(() => {\r\n      return fsx.realpathSync(linkPath);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * An async version of {@link FileSystem.getRealPath}.\r\n   */\r\n  public static async getRealPathAsync(linkPath: string): Promise<string> {\r\n    return await FileSystem._wrapExceptionAsync(() => {\r\n      return fsx.realpath(linkPath);\r\n    });\r\n  }\r\n\r\n  // ===============\r\n  // UTILITY FUNCTIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Returns true if the error provided indicates the file or folder does not exist.\r\n   */\r\n  public static isNotExistError(error: Error): boolean {\r\n    return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the error provided indicates the file does not exist.\r\n   */\r\n  public static isFileDoesNotExistError(error: Error): boolean {\r\n    return FileSystem.isErrnoException(error) && error.code === 'ENOENT';\r\n  }\r\n\r\n  /**\r\n   * Returns true if the error provided indicates the folder does not exist.\r\n   */\r\n  public static isFolderDoesNotExistError(error: Error): boolean {\r\n    return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';\r\n  }\r\n\r\n  /**\r\n   * Detects if the provided error object is a `NodeJS.ErrnoException`\r\n   */\r\n  public static isErrnoException(error: Error): error is NodeJS.ErrnoException {\r\n    const typedError: NodeJS.ErrnoException = error;\r\n    return (\r\n      typeof typedError.code === 'string' &&\r\n      typeof typedError.errno === 'number' &&\r\n      typeof typedError.path === 'string' &&\r\n      typeof typedError.syscall === 'string'\r\n    );\r\n  }\r\n\r\n  private static _wrapException<TResult>(fn: () => TResult): TResult {\r\n    try {\r\n      return fn();\r\n    } catch (error) {\r\n      FileSystem._updateErrorMessage(error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private static async _wrapExceptionAsync<TResult>(fn: () => Promise<TResult>): Promise<TResult> {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      FileSystem._updateErrorMessage(error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private static _updateErrorMessage(error: Error): void {\r\n    if (FileSystem.isErrnoException(error)) {\r\n      if (FileSystem.isFileDoesNotExistError(error)) {\r\n        // eslint-disable-line @typescript-eslint/no-use-before-define\r\n        error.message = `File does not exist: ${error.path}\\n${error.message}`;\r\n      } else if (FileSystem.isFolderDoesNotExistError(error)) {\r\n        // eslint-disable-line @typescript-eslint/no-use-before-define\r\n        error.message = `Folder does not exist: ${error.path}\\n${error.message}`;\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}