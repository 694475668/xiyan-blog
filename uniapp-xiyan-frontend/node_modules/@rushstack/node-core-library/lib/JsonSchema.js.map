{"version":3,"file":"JsonSchema.js","sourceRoot":"","sources":["../src/JsonSchema.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\n\r\nimport { JsonFile, JsonObject } from './JsonFile';\r\nimport { FileSystem } from './FileSystem';\r\n\r\nimport type ValidatorType from 'z-schema';\r\nconst Validator: typeof import('z-schema') = require('z-schema/dist/ZSchema-browser-min');\r\n\r\ninterface ISchemaWithId {\r\n  id: string | undefined;\r\n}\r\n\r\n/**\r\n * Callback function arguments for JsonSchema.validateObjectWithCallback();\r\n * @public\r\n */\r\nexport interface IJsonSchemaErrorInfo {\r\n  /**\r\n   * The z-schema error tree, formatted as an indented text string.\r\n   */\r\n  details: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.validateObject()\r\n * @public\r\n */\r\nexport interface IJsonSchemaValidateOptions {\r\n  /**\r\n   * A custom header that will be used to report schema errors.\r\n   * @remarks\r\n   * If omitted, the default header is \"JSON validation failed:\".  The error message starts with\r\n   * the header, followed by the full input filename, followed by the z-schema error tree.\r\n   * If you wish to customize all aspects of the error message, use JsonFile.loadAndValidateWithCallback()\r\n   * or JsonSchema.validateObjectWithCallback().\r\n   */\r\n  customErrorHeader?: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.fromFile()\r\n * @public\r\n */\r\nexport interface IJsonSchemaFromFileOptions {\r\n  /**\r\n   * Other schemas that this schema references, e.g. via the \"$ref\" directive.\r\n   * @remarks\r\n   * The tree of dependent schemas may reference the same schema more than once.\r\n   * However, if the same schema \"id\" is used by two different JsonSchema instances,\r\n   * an error will be reported.  This means you cannot load the same filename twice\r\n   * and use them both together, and you cannot have diamond dependencies on different\r\n   * versions of the same schema.  Although technically this would be possible to support,\r\n   * it normally indicates an error or design problem.\r\n   *\r\n   * JsonSchema also does not allow circular references between schema dependencies.\r\n   */\r\n  dependentSchemas?: JsonSchema[];\r\n}\r\n\r\n/**\r\n * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.\r\n * @remarks\r\n * The schema itself is normally loaded and compiled later, only if it is actually required to validate\r\n * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls\r\n * JsonSchema.ensureCompiled() for each of your schema objects.\r\n *\r\n * @public\r\n */\r\nexport class JsonSchema {\r\n  private _dependentSchemas: JsonSchema[] = [];\r\n  private _filename: string = '';\r\n  private _validator: ValidatorType | undefined = undefined;\r\n  private _schemaObject: JsonObject | undefined = undefined;\r\n\r\n  private constructor() {}\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema {\r\n    // This is a quick and inexpensive test to avoid the catch the most common errors early.\r\n    // Full validation will happen later in JsonSchema.compile().\r\n    if (!FileSystem.exists(filename)) {\r\n      throw new Error('Schema file not found: ' + filename);\r\n    }\r\n\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._filename = filename;\r\n\r\n    if (options) {\r\n      schema._dependentSchemas = options.dependentSchemas || [];\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromLoadedObject(schemaObject: JsonObject): JsonSchema {\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._schemaObject = schemaObject;\r\n    return schema;\r\n  }\r\n\r\n  private static _collectDependentSchemas(\r\n    collectedSchemas: JsonSchema[],\r\n    dependentSchemas: JsonSchema[],\r\n    seenObjects: Set<JsonSchema>,\r\n    seenIds: Set<string>\r\n  ): void {\r\n    for (const dependentSchema of dependentSchemas) {\r\n      // It's okay for the same schema to appear multiple times in the tree, but we only process it once\r\n      if (seenObjects.has(dependentSchema)) {\r\n        continue;\r\n      }\r\n      seenObjects.add(dependentSchema);\r\n\r\n      const schemaId: string = dependentSchema._ensureLoaded();\r\n      if (schemaId === '') {\r\n        throw new Error(\r\n          `This schema ${dependentSchema.shortName} cannot be referenced` +\r\n            ' because is missing the \"id\" field'\r\n        );\r\n      }\r\n      if (seenIds.has(schemaId)) {\r\n        throw new Error(\r\n          `This schema ${dependentSchema.shortName} has the same \"id\" as another schema in this set`\r\n        );\r\n      }\r\n\r\n      seenIds.add(schemaId);\r\n\r\n      collectedSchemas.push(dependentSchema);\r\n\r\n      JsonSchema._collectDependentSchemas(\r\n        collectedSchemas,\r\n        dependentSchema._dependentSchemas,\r\n        seenObjects,\r\n        seenIds\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to nicely format the ZSchema error tree.\r\n   */\r\n  private static _formatErrorDetails(errorDetails: ValidatorType.SchemaErrorDetail[]): string {\r\n    return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');\r\n  }\r\n\r\n  /**\r\n   * Used by _formatErrorDetails.\r\n   */\r\n  private static _formatErrorDetailsHelper(\r\n    errorDetails: ValidatorType.SchemaErrorDetail[],\r\n    indent: string,\r\n    buffer: string\r\n  ): string {\r\n    for (const errorDetail of errorDetails) {\r\n      buffer += os.EOL + indent + `Error: ${errorDetail.path}`;\r\n\r\n      if (errorDetail.description) {\r\n        const MAX_LENGTH: number = 40;\r\n        let truncatedDescription: string = errorDetail.description.trim();\r\n        if (truncatedDescription.length > MAX_LENGTH) {\r\n          truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';\r\n        }\r\n\r\n        buffer += ` (${truncatedDescription})`;\r\n      }\r\n\r\n      buffer += os.EOL + indent + `       ${errorDetail.message}`;\r\n\r\n      if (errorDetail.inner) {\r\n        buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Returns a short name for this schema, for use in error messages.\r\n   * @remarks\r\n   * If the schema was loaded from a file, then the base filename is used.  Otherwise, the \"id\"\r\n   * field is used if available.\r\n   */\r\n  public get shortName(): string {\r\n    if (!this._filename) {\r\n      if (this._schemaObject) {\r\n        const schemaWithId: ISchemaWithId = this._schemaObject as ISchemaWithId;\r\n        if (schemaWithId.id) {\r\n          return schemaWithId.id;\r\n        }\r\n      }\r\n      return '(anonymous schema)';\r\n    } else {\r\n      return path.basename(this._filename);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If not already done, this loads the schema from disk and compiles it.\r\n   * @remarks\r\n   * Any dependencies will be compiled as well.\r\n   */\r\n  public ensureCompiled(): void {\r\n    this._ensureLoaded();\r\n\r\n    if (!this._validator) {\r\n      // Don't assign this to _validator until we're sure everything was successful\r\n      const newValidator: ValidatorType = new Validator({\r\n        breakOnFirstError: false,\r\n        noTypeless: true,\r\n        noExtraKeywords: true\r\n      });\r\n\r\n      const anythingSchema: JsonObject = {\r\n        type: ['array', 'boolean', 'integer', 'number', 'object', 'string']\r\n      };\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      (newValidator as any).setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);\r\n\r\n      const collectedSchemas: JsonSchema[] = [];\r\n      const seenObjects: Set<JsonSchema> = new Set<JsonSchema>();\r\n      const seenIds: Set<string> = new Set<string>();\r\n\r\n      JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);\r\n\r\n      // Validate each schema in order.  We specifically do not supply them all together, because we want\r\n      // to make sure that circular references will fail to validate.\r\n      for (const collectedSchema of collectedSchemas) {\r\n        if (!newValidator.validateSchema(collectedSchema._schemaObject)) {\r\n          throw new Error(\r\n            `Failed to validate schema \"${collectedSchema.shortName}\":` +\r\n              os.EOL +\r\n              JsonSchema._formatErrorDetails(newValidator.getLastErrors())\r\n          );\r\n        }\r\n      }\r\n\r\n      this._validator = newValidator;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * an exception will be thrown.\r\n   * @param jsonObject - The JSON data to be validated\r\n   * @param filenameForErrors - The filename that the JSON data was available, or an empty string\r\n   *    if not applicable\r\n   * @param options - Other options that control the validation\r\n   */\r\n  public validateObject(\r\n    jsonObject: JsonObject,\r\n    filenameForErrors: string,\r\n    options?: IJsonSchemaValidateOptions\r\n  ): void {\r\n    this.validateObjectWithCallback(jsonObject, (errorInfo: IJsonSchemaErrorInfo) => {\r\n      const prefix: string =\r\n        options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';\r\n\r\n      throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * a callback is called for each validation error.\r\n   */\r\n  public validateObjectWithCallback(\r\n    jsonObject: JsonObject,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void\r\n  ): void {\r\n    this.ensureCompiled();\r\n\r\n    if (!this._validator!.validate(jsonObject, this._schemaObject)) {\r\n      const errorDetails: string = JsonSchema._formatErrorDetails(this._validator!.getLastErrors());\r\n\r\n      const args: IJsonSchemaErrorInfo = {\r\n        details: errorDetails\r\n      };\r\n      errorCallback(args);\r\n    }\r\n  }\r\n\r\n  private _ensureLoaded(): string {\r\n    if (!this._schemaObject) {\r\n      this._schemaObject = JsonFile.load(this._filename);\r\n    }\r\n    return (this._schemaObject as ISchemaWithId).id || '';\r\n  }\r\n}\r\n"]}