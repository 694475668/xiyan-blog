{"version":3,"file":"BaseClasses.js","sourceRoot":"","sources":["../../src/parameters/BaseClasses.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { IBaseCommandLineDefinition, IBaseCommandLineDefinitionWithArgument } from './CommandLineDefinition';\r\n\r\n/**\r\n * Identifies the kind of a CommandLineParameter.\r\n * @public\r\n */\r\nexport enum CommandLineParameterKind {\r\n  /** Indicates a CommandLineChoiceParameter */\r\n  Choice,\r\n  /** Indicates a CommandLineFlagParameter */\r\n  Flag,\r\n  /** Indicates a CommandLineIntegerParameter */\r\n  Integer,\r\n  /** Indicates a CommandLineStringParameter */\r\n  String,\r\n  /** Indicates a CommandLineStringListParameter */\r\n  StringList\r\n}\r\n\r\n/**\r\n * The base class for the various command-line parameter types.\r\n * @public\r\n */\r\nexport abstract class CommandLineParameter {\r\n  // Example: \"--do-something\"\r\n  private static _longNameRegExp: RegExp = /^-(-[a-z0-9]+)+$/;\r\n\r\n  // Example: \"-d\"\r\n  private static _shortNameRegExp: RegExp = /^-[a-zA-Z]$/;\r\n\r\n  // \"Environment variable names used by the utilities in the Shell and Utilities volume of\r\n  // IEEE Std 1003.1-2001 consist solely of uppercase letters, digits, and the '_' (underscore)\r\n  // from the characters defined in Portable Character Set and do not begin with a digit.\"\r\n  // Example: \"THE_SETTING\"\r\n  private static _environmentVariableRegExp: RegExp = /^[A-Z_][A-Z0-9_]*$/;\r\n\r\n  /**\r\n   * A unique internal key used to retrieve the value from the parser's dictionary.\r\n   * @internal\r\n   */\r\n  public _parserKey: string | undefined;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.parameterLongName} */\r\n  public readonly longName: string;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.parameterShortName} */\r\n  public readonly shortName: string | undefined;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.description} */\r\n  public readonly description: string;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.required} */\r\n  public readonly required: boolean;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.environmentVariable} */\r\n  public readonly environmentVariable: string | undefined;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinition.undocumentedSynonyms } */\r\n  public readonly undocumentedSynonyms: string[] | undefined;\r\n\r\n  /** @internal */\r\n  public constructor(definition: IBaseCommandLineDefinition) {\r\n    this.longName = definition.parameterLongName;\r\n    this.shortName = definition.parameterShortName;\r\n    this.description = definition.description;\r\n    this.required = !!definition.required;\r\n    this.environmentVariable = definition.environmentVariable;\r\n    this.undocumentedSynonyms = definition.undocumentedSynonyms;\r\n\r\n    if (!CommandLineParameter._longNameRegExp.test(this.longName)) {\r\n      throw new Error(\r\n        `Invalid name: \"${this.longName}\". The parameter long name must be` +\r\n          ` lower-case and use dash delimiters (e.g. \"--do-a-thing\")`\r\n      );\r\n    }\r\n\r\n    if (this.shortName) {\r\n      if (!CommandLineParameter._shortNameRegExp.test(this.shortName)) {\r\n        throw new Error(\r\n          `Invalid name: \"${this.shortName}\". The parameter short name must be` +\r\n            ` a dash followed by a single upper-case or lower-case letter (e.g. \"-a\")`\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this.environmentVariable) {\r\n      if (this.required) {\r\n        // TODO: This constraint is imposed only because argparse enforces \"required\" parameters, but\r\n        // it does not know about ts-command-line environment variable mappings.  We should fix this.\r\n        throw new Error(\r\n          `An \"environmentVariable\" cannot be specified for \"${this.longName}\"` +\r\n            ` because it is a required parameter`\r\n        );\r\n      }\r\n\r\n      if (!CommandLineParameter._environmentVariableRegExp.test(this.environmentVariable)) {\r\n        throw new Error(\r\n          `Invalid environment variable name: \"${this.environmentVariable}\". The name must` +\r\n            ` consist only of upper-case letters, numbers, and underscores. It may not start with a number.`\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this.undocumentedSynonyms && this.undocumentedSynonyms.length > 0) {\r\n      if (this.required) {\r\n        throw new Error('Undocumented synonyms are not allowed on required parameters.');\r\n      }\r\n\r\n      for (const undocumentedSynonym of this.undocumentedSynonyms) {\r\n        if (this.longName === undocumentedSynonym) {\r\n          throw new Error(\r\n            `Invalid name: \"${undocumentedSynonym}\". Undocumented Synonyms must not be the same` +\r\n              ` as the the long name.`\r\n          );\r\n        } else if (!CommandLineParameter._longNameRegExp.test(undocumentedSynonym)) {\r\n          throw new Error(\r\n            `Invalid name: \"${undocumentedSynonym}\". All undocumented Synonyms name must be` +\r\n              ` lower-case and use dash delimiters (e.g. \"--do-a-thing\")`\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called internally by CommandLineParameterProvider._processParsedData()\r\n   * @internal\r\n   */\r\n  public abstract _setValue(data: any): void; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n\r\n  /**\r\n   * Returns additional text used by the help formatter.\r\n   * @internal\r\n   */\r\n  public _getSupplementaryNotes(supplementaryNotes: string[]): void {\r\n    // virtual\r\n    if (this.environmentVariable !== undefined) {\r\n      supplementaryNotes.push(\r\n        'This parameter may alternatively be specified via the ' +\r\n          this.environmentVariable +\r\n          ' environment variable.'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates the type of parameter.\r\n   */\r\n  public abstract get kind(): CommandLineParameterKind;\r\n\r\n  /**\r\n   * Append the parsed values to the provided string array.\r\n   * @remarks\r\n   * Sometimes a command line parameter is not used directly, but instead gets passed through to another\r\n   * tool that will use it.  For example if our parameter comes in as \"--max-count 3\", then we might want to\r\n   * call `child_process.spawn()` and append [\"--max-count\", \"3\"] to the args array for that tool.\r\n   * appendToArgList() appends zero or more strings to the provided array, based on the input command-line\r\n   * that we parsed.\r\n   *\r\n   * If the parameter was omitted from our command-line and has no default value, then\r\n   * nothing will be appended.  If the short name was used, the long name will be appended instead.\r\n   * @param argList - the parsed strings will be appended to this string array\r\n   */\r\n  public abstract appendToArgList(argList: string[]): void;\r\n\r\n  /**\r\n   * Internal usage only.  Used to report unexpected output from the argparse library.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  protected reportInvalidData(data: any): never {\r\n    throw new Error(`Unexpected data object for parameter \"${this.longName}\": ` + JSON.stringify(data));\r\n  }\r\n\r\n  protected validateDefaultValue(hasDefaultValue: boolean): void {\r\n    if (this.required && hasDefaultValue) {\r\n      // If a parameter is \"required\", then the user understands that they always need to\r\n      // specify a value for this parameter (either via the command line or via an environment variable).\r\n      // It would be confusing to allow a default value that sometimes allows the \"required\" parameter\r\n      // to be omitted.  If you sometimes don't have a suitable default value, then the better approach\r\n      // is to throw a custom error explaining why the parameter is required in that case.\r\n      throw new Error(\r\n        `A default value cannot be specified for \"${this.longName}\" because it is a \"required\" parameter`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The common base class for parameters types that receive an argument.\r\n *\r\n * @remarks\r\n * An argument is an accompanying command-line token, such as \"123\" in the\r\n * example \"--max-count 123\".\r\n * @public\r\n */\r\nexport abstract class CommandLineParameterWithArgument extends CommandLineParameter {\r\n  // Matches the first character that *isn't* part of a valid upper-case argument name such as \"URL_2\"\r\n  private static _invalidArgumentNameRegExp: RegExp = /[^A-Z_0-9]/;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinitionWithArgument.argumentName} */\r\n  public readonly argumentName: string;\r\n\r\n  /** {@inheritDoc IBaseCommandLineDefinitionWithArgument.completions} */\r\n  public readonly completions: (() => Promise<string[]>) | undefined;\r\n\r\n  /** @internal */\r\n  public constructor(definition: IBaseCommandLineDefinitionWithArgument) {\r\n    super(definition);\r\n\r\n    if (definition.argumentName === '') {\r\n      throw new Error(\r\n        'The argument name cannot be an empty string. (For the default name, specify undefined.)'\r\n      );\r\n    }\r\n    if (definition.argumentName.toUpperCase() !== definition.argumentName) {\r\n      throw new Error(\r\n        `Invalid name: \"${definition.argumentName}\". The argument name must be all upper case.`\r\n      );\r\n    }\r\n    const match: RegExpMatchArray | null = definition.argumentName.match(\r\n      CommandLineParameterWithArgument._invalidArgumentNameRegExp\r\n    );\r\n    if (match) {\r\n      throw new Error(\r\n        `The argument name \"${definition.argumentName}\" contains an invalid character \"${match[0]}\".` +\r\n          ` Only upper-case letters, numbers, and underscores are allowed.`\r\n      );\r\n    }\r\n    this.argumentName = definition.argumentName;\r\n    this.completions = definition.completions;\r\n  }\r\n}\r\n"]}