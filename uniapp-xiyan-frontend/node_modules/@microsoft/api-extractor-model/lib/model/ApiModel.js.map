{"version":3,"file":"ApiModel.js","sourceRoot":"","sources":["../../src/model/ApiModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\r\nimport { ApiItem, ApiItemKind } from '../items/ApiItem';\r\nimport { ApiItemContainerMixin } from '../mixins/ApiItemContainerMixin';\r\nimport { ApiPackage } from './ApiPackage';\r\nimport { PackageName } from '@rushstack/node-core-library';\r\nimport { ModelReferenceResolver, IResolveDeclarationReferenceResult } from './ModelReferenceResolver';\r\nimport { DocDeclarationReference } from '@microsoft/tsdoc';\r\n\r\n/**\r\n * A serializable representation of a collection of API declarations.\r\n *\r\n * @remarks\r\n *\r\n * An `ApiModel` represents a collection of API declarations that can be serialized to disk.  It captures all the\r\n * important information needed to generate documentation, without any reliance on the TypeScript compiler engine.\r\n *\r\n * An `ApiModel` acts as the root of a tree of objects that all inherit from the `ApiItem` base class.\r\n * The tree children are determined by the {@link (ApiItemContainerMixin:interface)} mixin base class.  The model\r\n * contains packages.  Packages have an entry point (today, only one).  And the entry point can contain various types\r\n * of API declarations.  The container relationships might look like this:\r\n *\r\n * ```\r\n * Things that can contain other things:\r\n *\r\n * - ApiModel\r\n *   - ApiPackage\r\n *     - ApiEntryPoint\r\n *       - ApiClass\r\n *         - ApiMethod\r\n *         - ApiProperty\r\n *       - ApiEnum\r\n *         - ApiEnumMember\r\n *       - ApiInterface\r\n *         - ApiMethodSignature\r\n *         - ApiPropertySignature\r\n *       - ApiNamespace\r\n *         - (ApiClass, ApiEnum, ApiInterace, ...)\r\n *\r\n * ```\r\n *\r\n * Normally, API Extractor writes an .api.json file to disk for each project that it builds.  Then, a tool like\r\n * API Documenter can load the various `ApiPackage` objects into a single `ApiModel` and process them as a group.\r\n * This is useful because compilation generally occurs separately (e.g. because projects may reside in different\r\n * Git repos, or because they build with different TypeScript compiler configurations that may be incompatible),\r\n * whereas API Documenter cannot detect broken hyperlinks without seeing the entire documentation set.\r\n *\r\n * @public\r\n */\r\nexport class ApiModel extends ApiItemContainerMixin(ApiItem) {\r\n  private readonly _resolver: ModelReferenceResolver;\r\n\r\n  private _packagesByName: Map<string, ApiPackage> | undefined = undefined;\r\n  private _apiItemsByCanonicalReference: Map<string, ApiItem> | undefined = undefined;\r\n  public constructor() {\r\n    super({});\r\n\r\n    this._resolver = new ModelReferenceResolver(this);\r\n  }\r\n\r\n  public loadPackage(apiJsonFilename: string): ApiPackage {\r\n    const apiPackage: ApiPackage = ApiPackage.loadFromJsonFile(apiJsonFilename);\r\n    this.addMember(apiPackage);\r\n    return apiPackage;\r\n  }\r\n\r\n  /** @override */\r\n  public get kind(): ApiItemKind {\r\n    return ApiItemKind.Model;\r\n  }\r\n\r\n  /** @override */\r\n  public get containerKey(): string {\r\n    return '';\r\n  }\r\n\r\n  public get packages(): ReadonlyArray<ApiPackage> {\r\n    return this.members as ReadonlyArray<ApiPackage>;\r\n  }\r\n\r\n  /** @override */\r\n  public addMember(member: ApiPackage): void {\r\n    if (member.kind !== ApiItemKind.Package) {\r\n      throw new Error('Only items of type ApiPackage may be added to an ApiModel');\r\n    }\r\n    super.addMember(member);\r\n    this._packagesByName = undefined; // invalidate the cache\r\n    this._apiItemsByCanonicalReference = undefined; // invalidate the cache\r\n  }\r\n\r\n  /**\r\n   * Efficiently finds a package by the NPM package name.\r\n   *\r\n   * @remarks\r\n   *\r\n   * If the NPM scope is omitted in the package name, it will still be found provided that it is an unambiguous match.\r\n   * For example, it's often convenient to write `{@link node-core-library#JsonFile}` instead of\r\n   * `{@link @rushstack/node-core-library#JsonFile}`.\r\n   */\r\n  public tryGetPackageByName(packageName: string): ApiPackage | undefined {\r\n    // Build the lookup on demand\r\n    if (this._packagesByName === undefined) {\r\n      this._packagesByName = new Map<string, ApiPackage>();\r\n\r\n      const unscopedMap: Map<string, ApiPackage | undefined> = new Map<string, ApiPackage | undefined>();\r\n\r\n      for (const apiPackage of this.packages) {\r\n        if (this._packagesByName.get(apiPackage.name)) {\r\n          // This should not happen\r\n          throw new Error(`The model contains multiple packages with the name ${apiPackage.name}`);\r\n        }\r\n\r\n        this._packagesByName.set(apiPackage.name, apiPackage);\r\n\r\n        const unscopedName: string = PackageName.parse(apiPackage.name).unscopedName;\r\n\r\n        if (unscopedMap.has(unscopedName)) {\r\n          // If another package has the same unscoped name, then we won't register it\r\n          unscopedMap.set(unscopedName, undefined);\r\n        } else {\r\n          unscopedMap.set(unscopedName, apiPackage);\r\n        }\r\n      }\r\n\r\n      for (const [unscopedName, apiPackage] of unscopedMap) {\r\n        if (apiPackage) {\r\n          if (!this._packagesByName.has(unscopedName)) {\r\n            // If the unscoped name is unambiguous, then we can also use it as a lookup\r\n            this._packagesByName.set(unscopedName, apiPackage);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return this._packagesByName.get(packageName);\r\n  }\r\n\r\n  public resolveDeclarationReference(\r\n    declarationReference: DocDeclarationReference | DeclarationReference,\r\n    contextApiItem: ApiItem | undefined\r\n  ): IResolveDeclarationReferenceResult {\r\n    if (declarationReference instanceof DocDeclarationReference) {\r\n      return this._resolver.resolve(declarationReference, contextApiItem);\r\n    } else if (declarationReference instanceof DeclarationReference) {\r\n      // use this._apiItemsByCanonicalReference to look up ApiItem\r\n\r\n      // Build the lookup on demand\r\n      if (!this._apiItemsByCanonicalReference) {\r\n        this._apiItemsByCanonicalReference = new Map<string, ApiItem>();\r\n\r\n        for (const apiPackage of this.packages) {\r\n          this._initApiItemsRecursive(apiPackage, this._apiItemsByCanonicalReference);\r\n        }\r\n      }\r\n\r\n      const result: IResolveDeclarationReferenceResult = {\r\n        resolvedApiItem: undefined,\r\n        errorMessage: undefined\r\n      };\r\n\r\n      const apiItem: ApiItem | undefined = this._apiItemsByCanonicalReference.get(\r\n        declarationReference.toString()\r\n      );\r\n\r\n      if (!apiItem) {\r\n        result.errorMessage = `${declarationReference.toString()} can not be located`;\r\n      } else {\r\n        result.resolvedApiItem = apiItem;\r\n      }\r\n\r\n      return result;\r\n    } else {\r\n      // NOTE: The \"instanceof DeclarationReference\" test assumes a specific version of the @microsoft/tsdoc package.\r\n      throw new Error(\r\n        'The \"declarationReference\" parameter must be an instance of' +\r\n          ' DocDeclarationReference or DeclarationReference'\r\n      );\r\n    }\r\n  }\r\n\r\n  private _initApiItemsRecursive(apiItem: ApiItem, apiItemsByCanonicalReference: Map<string, ApiItem>): void {\r\n    if (apiItem.canonicalReference && !apiItem.canonicalReference.isEmpty) {\r\n      apiItemsByCanonicalReference.set(apiItem.canonicalReference.toString(), apiItem);\r\n    }\r\n\r\n    // Recurse container members\r\n    if (ApiItemContainerMixin.isBaseClassOf(apiItem)) {\r\n      for (const apiMember of apiItem.members) {\r\n        this._initApiItemsRecursive(apiMember, apiItemsByCanonicalReference);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @beta @override */\r\n  public buildCanonicalReference(): DeclarationReference {\r\n    return DeclarationReference.empty();\r\n  }\r\n}\r\n"]}