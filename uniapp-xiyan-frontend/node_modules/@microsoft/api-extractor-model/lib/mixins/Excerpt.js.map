{"version":3,"file":"Excerpt.js","sourceRoot":"","sources":["../../src/mixins/Excerpt.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,oEAAoD;AA2CpD;;;;GAIG;AACH,MAAa,YAAY;IAKvB,YAAmB,IAAsB,EAAE,IAAY,EAAE,kBAAyC;QAChG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,kGAAkG;QAClG,4FAA4F;QAC5F,kFAAkF;QAClF,IAAI,CAAC,KAAK,GAAG,wBAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;;OAGG;IACH,IAAW,kBAAkB;QAC3B,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC,CAAC;CACF;AApCD,oCAoCC;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAa,OAAO;IAqBlB,YAAmB,MAAmC,EAAE,UAA8B;QACpF,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAE7B,IACE,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC;YAC9B,IAAI,CAAC,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM;YAC7C,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EACrD;YACA,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;SACxC;QAED,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;IAC/F,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC7D;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,UAAU,CAAC,UAAU,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;IACjE,CAAC;CACF;AApDD,0BAoDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\r\nimport { Text } from '@rushstack/node-core-library';\r\n\r\n/** @public */\r\nexport const enum ExcerptTokenKind {\r\n  /**\r\n   * Generic text without any special properties\r\n   */\r\n  Content = 'Content',\r\n\r\n  /**\r\n   * A reference to an API declaration\r\n   */\r\n  Reference = 'Reference'\r\n}\r\n\r\n/**\r\n * Used by {@link Excerpt} to indicate a range of indexes within an array of `ExcerptToken` objects.\r\n *\r\n * @public\r\n */\r\nexport interface IExcerptTokenRange {\r\n  /**\r\n   * The starting index of the span.\r\n   */\r\n  startIndex: number;\r\n\r\n  /**\r\n   * The index of the last member of the span, plus one.\r\n   *\r\n   * @remarks\r\n   *\r\n   * If `startIndex` and `endIndex` are the same number, then the span is empty.\r\n   */\r\n  endIndex: number;\r\n}\r\n\r\n/** @public */\r\nexport interface IExcerptToken {\r\n  readonly kind: ExcerptTokenKind;\r\n  text: string;\r\n  canonicalReference?: string;\r\n}\r\n\r\n/**\r\n * Represents a fragment of text belonging to an {@link Excerpt} object.\r\n *\r\n * @public\r\n */\r\nexport class ExcerptToken {\r\n  private readonly _kind: ExcerptTokenKind;\r\n  private readonly _text: string;\r\n  private readonly _canonicalReference: DeclarationReference | undefined;\r\n\r\n  public constructor(kind: ExcerptTokenKind, text: string, canonicalReference?: DeclarationReference) {\r\n    this._kind = kind;\r\n\r\n    // Standardize the newlines across operating systems. Even though this may deviate from the actual\r\n    // input source file that was parsed, it's useful because the newline gets serialized inside\r\n    // a string literal in .api.json, which cannot be automatically normalized by Git.\r\n    this._text = Text.convertToLf(text);\r\n    this._canonicalReference = canonicalReference;\r\n  }\r\n\r\n  /**\r\n   * Indicates the kind of token.\r\n   */\r\n  public get kind(): ExcerptTokenKind {\r\n    return this._kind;\r\n  }\r\n\r\n  /**\r\n   * The text fragment.\r\n   */\r\n  public get text(): string {\r\n    return this._text;\r\n  }\r\n\r\n  /**\r\n   * The hyperlink target for a token whose type is `ExcerptTokenKind.Reference`.  For other token types,\r\n   * this property will be `undefined`.\r\n   */\r\n  public get canonicalReference(): DeclarationReference | undefined {\r\n    return this._canonicalReference;\r\n  }\r\n}\r\n\r\n/**\r\n * The `Excerpt` class is used by {@link ApiDeclaredItem} to represent a TypeScript code fragment that may be\r\n * annotated with hyperlinks to declared types (and in the future, source code locations).\r\n *\r\n * @remarks\r\n * API Extractor's .api.json file format stores excerpts compactly as a start/end indexes into an array of tokens.\r\n * Every `ApiDeclaredItem` has a \"main excerpt\" corresponding to the full list of tokens.  The declaration may\r\n * also have have \"captured\" excerpts that correspond to subranges of tokens.\r\n *\r\n * For example, if the main excerpt is:\r\n *\r\n * ```\r\n * function parse(s: string): Vector | undefined;\r\n * ```\r\n *\r\n * ...then this entire signature is the \"main excerpt\", whereas the function's return type `Vector | undefined` is a\r\n * captured excerpt.  The `Vector` token might be a hyperlink to that API item.\r\n *\r\n * An excerpt may be empty (i.e. a token range containing zero tokens).  For example, if a function's return value\r\n * is not explicitly declared, then the returnTypeExcerpt will be empty.  By contrast, a class constructor cannot\r\n * have a return value, so ApiConstructor has no returnTypeExcerpt property at all.\r\n *\r\n * @public\r\n */\r\nexport class Excerpt {\r\n  /**\r\n   * The complete list of tokens for the source code fragment that this excerpt is based upon.\r\n   * If this object is the main excerpt, then it will span all of the tokens; otherwise, it will correspond to\r\n   * a range within the array.\r\n   */\r\n  public readonly tokens: ReadonlyArray<ExcerptToken>;\r\n\r\n  /**\r\n   * Specifies the excerpt's range within the `tokens` array.\r\n   */\r\n  public readonly tokenRange: Readonly<IExcerptTokenRange>;\r\n\r\n  /**\r\n   * The tokens spanned by this excerpt.  It is the range of the `tokens` array as specified by the `tokenRange`\r\n   * property.\r\n   */\r\n  public readonly spannedTokens: ReadonlyArray<ExcerptToken>;\r\n\r\n  private _text: string | undefined;\r\n\r\n  public constructor(tokens: ReadonlyArray<ExcerptToken>, tokenRange: IExcerptTokenRange) {\r\n    this.tokens = tokens;\r\n    this.tokenRange = tokenRange;\r\n\r\n    if (\r\n      this.tokenRange.startIndex < 0 ||\r\n      this.tokenRange.endIndex > this.tokens.length ||\r\n      this.tokenRange.startIndex > this.tokenRange.endIndex\r\n    ) {\r\n      throw new Error('Invalid token range');\r\n    }\r\n\r\n    this.spannedTokens = this.tokens.slice(this.tokenRange.startIndex, this.tokenRange.endIndex);\r\n  }\r\n\r\n  /**\r\n   * The excerpted text, formed by concatenating the text of the `spannedTokens` strings.\r\n   */\r\n  public get text(): string {\r\n    if (this._text === undefined) {\r\n      this._text = this.spannedTokens.map((x) => x.text).join('');\r\n    }\r\n    return this._text;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the excerpt is an empty range.\r\n   */\r\n  public get isEmpty(): boolean {\r\n    return this.tokenRange.startIndex === this.tokenRange.endIndex;\r\n  }\r\n}\r\n"]}